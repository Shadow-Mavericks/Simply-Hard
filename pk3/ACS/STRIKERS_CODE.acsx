#Library "STRIKERS_CODE"
#include "zcommon.acs"

// All code in this file is by StrikerTheHedgefox.
// Please ask permission if you want to use this!

function bool startsWithVowel(str string)
{
	switch (GetChar(string, 0))
	{
		case 'a':
		case 'e':
		case 'i':
		case 'o':
		case 'u':
		case 'A':
		case 'E':
		case 'I':
		case 'O':
		case 'U':
			return true;
			break;
	}

	return false;
}

function int min (int a, int b)
{
	if (a < b)
		return a;

	return b;
}

function int max (int a, int b)
{
	if (a > b)
		return a;

	return b;
}

function int abs (int x)
{
	if (x < 0)
		return -x;

	return x;
}

function int clamp(int in, int min, int max)
{
	int out = (in < min) ? min : in;
	return (out > max) ? max : out;
}

function str GetClassTag(str className)
{
	int uTID = UniqueTID();

	if(!SpawnForced(className, 0, 0, 0, uTID, 0))
		return className;

	str tag = GetActorProperty(uTID, APROP_NameTag);
	Thing_Remove(uTID);
	return tag;
}

// Imported from Korshun's ACSUtils, because Zandronum is an outdated piece of shit that doesn't seem
// to have basic, important functions that have existed since 2016.
function str ACSUtils_ChangeFlagName(str flag, bool value)
{
	return StrParam(s:"ACSUtils_CF_", s:flag, s:"_", d:(!!value));
}

function void ChangeFlag(str flag, bool value)
{
	GiveInventory(ACSUtils_ChangeFlagName(flag, value), 1);
}

function void ChangeActorFlag(int tid, str flag, bool value)
{
	GiveActorInventory(tid, ACSUtils_ChangeFlagName(flag, value), 1);
}

// Kill script, for things like orbs, lives, and box drops.
script "ON_KILL" KILL
{
	if(!CheckFlag(0, "ISMONSTER")) // Not monster? Don't bother.
		terminate;

	SetHudSize(640, 480, true);

	int i;

	// Get some properties of our monster.
	str Class = GetActorClass(0);
	int Health = GetActorProperty(0, APROP_SpawnHealth);
	int Height = GetActorProperty(0, APROP_Height);
	int Damage = GetActorProperty(0, APROP_Damage);

	// Base velocities for Orbs
	int HOrbSpeed = max(GetActorProperty(0, APROP_Radius) / 4, 6.0);
	int VOrbSpeed = max(Height/6, 6.0);

	int NumOrbs = 0;

	if(GetCVar("sh_orbs_logarithmic"))
	{
		// Base Multiplier * Health / (Health + Speed of Deminishing Return)
		NumOrbs = 50 * Health / (Health + 1500); // Calculate number of Orbs.
	}
	else
	{
		NumOrbs = Health/40;
	}

	// Certain flags add a bonus.
	if(CheckFlag(0, "MISSILEMORE"))			NumOrbs += 1;
	if(CheckFlag(0, "MISSILEEVENMORE"))		NumOrbs += 1;
	if(CheckFlag(0, "SPECTRAL"))			NumOrbs += 1;
	if(CheckFlag(0, "DONTRIP"))				NumOrbs += 1;
	if(CheckFlag(0, "NOICEDEATH"))			NumOrbs += 1;
	if(CheckFlag(0, "STEALTH"))				NumOrbs += 2;
	if(CheckFlag(0, "ALWAYSFAST"))			NumOrbs += 2;
	if(CheckFlag(0, "NORADIUSDMG"))			NumOrbs += 2;
	if(CheckFlag(0, "BOSS"))				NumOrbs += 10; // Bosses get more orbs.

	if(Damage >= 250) // Super high damage enemies (like the white rabbit) double orbs.
		NumOrbs *= 2;

	if(NumOrbs <= 0) // Everything is worth at least one orb.
		NumOrbs = 1;

	for(i = 0; i < NumOrbs; i++)
	{
		int TID = UniqueTID (0, 0);
		SpawnForced("DEMONENERGY", GetActorX(0), GetActorY(0), GetActorZ(0)+(Height/2), TID, random(0, 255));
		SetActorVelocity(TID, random(-HOrbSpeed, HOrbSpeed), random(-HOrbSpeed, HOrbSpeed), random(2.0, VOrbSpeed), false, false);
		Thing_ChangeTID(TID, 0);
	}

	// Extra Life Drops
	// ----------------
	if(GetUserVariable(0, "user_extralife_chance") != -1) // -1 = No spawn
	{
		bool doLifeSpawn = false;
		int lifeRandom = Random(1, 200);
		if(GetUserVariable(0, "user_extralife_chance") > 0)
		{
			if(lifeRandom <= GetUserVariable(0, "user_extralife_chance"))
				doLifeSpawn = true;
		}
		else
		{
			if(Health >= 6000) // 100%
				doLifeSpawn = true;
			else if(Health >= 5000 && lifeRandom <= 150) // 75%
				doLifeSpawn = true;
			else if(Health >= 4000 && lifeRandom <= 100) // 50%
				doLifeSpawn = true;
			else if(Health >= 3000 && lifeRandom <= 80) // 40%
				doLifeSpawn = true;
			else if(Health >= 2500 && lifeRandom <= 20) // 10%
				doLifeSpawn = true;
			else if(Health >= 1000 && lifeRandom <= 2) // 1%
				doLifeSpawn = true;
			else if(Health >= 500 && lifeRandom <= 1) // 0.5%
				doLifeSpawn = true;
		}

		if(doLifeSpawn)
		{
			int lifeTID = UniqueTID (0, 0);
			SpawnForced("extralifethingy", GetActorX(0), GetActorY(0), GetActorZ(0)+(Height/2), lifeTID, random(0, 255));
			SetActorVelocity(lifeTID, random(-HOrbSpeed/2, HOrbSpeed/2), random(-HOrbSpeed/2, HOrbSpeed/2), random(2.0, VOrbSpeed), false, false);

			if(Health >= 8000) // Spawn another if health pool is massive.
			{
				lifeTID = UniqueTID (0, 0);
				SpawnForced("extralifethingy", GetActorX(0), GetActorY(0), GetActorZ(0)+(Height/2), lifeTID, random(0, 255));
				SetActorVelocity(lifeTID, random(-HOrbSpeed/2, HOrbSpeed/2), random(-HOrbSpeed/2, HOrbSpeed/2), random(2.0, VOrbSpeed), false, false);

				HudMessageBold(s:"Two extra lives were dropped by ", s:(startsWithVowel(StrParam(n:0))) ? "an " : "a ", n:0;
				HUDMSG_TYPEON | HUDMSG_LOG, 69, CR_CYAN, 320.0, 120.0, 5.0, 0.01, 0.5);
			}
			else
			{
				HudMessageBold(s:"An extra life was dropped by ", s:(startsWithVowel(StrParam(n:0))) ? "an " : "a ", n:0;
				HUDMSG_TYPEON | HUDMSG_LOG, 69, CR_CYAN, 320.0, 120.0, 5.0, 0.01, 0.5);
			}
		}
	}

	// ManCo Box Drops
	// ---------------
	if(GetUserVariable(0, "user_manncobox_chance") != -1)
	{
		bool doBoxSpawn = false;
		int boxRandom = Random(1, 400);
		int boxChance = Health/40;

		if(CheckFlag(0, "BOSS") || CheckFlag(0, "BOSSDEATH"))
			boxChance += 10;

		if (boxChance > 400)
			boxChance = 400;
		else if (boxChance < 1)
			boxChance = 1;

		if(GetUserVariable(0, "user_manncobox_chance") > 0)
		{
			if(boxRandom <= GetUserVariable(0, "user_manncobox_chance"))
				doBoxSpawn = true;
		}
		else if(boxRandom <= boxChance && Health > 15)
			doBoxSpawn = true;

		if(doBoxSpawn)
		{
			int tierWeights[5] = { 1, 2, 4, 6, 8 };
			int maxTier = 1;
			int totalWeight = 0;

			if(Health >= 500) // Tier 2
				maxTier++;
			if(Health >= 1000) // Tier 3
				maxTier++;
			if(Health >= 2500) // Tier 4
				maxTier++;
			if(Health >= 4000) // Tier 5
				maxTier++;

			if(Health < 2500 && (CheckFlag(0, "BOSS") || CheckFlag(0, "BOSSDEATH"))) // If low health enemy is boss, boost.
				maxTier++;

			if(maxTier > 5)
				maxTier = 5;

			// This should make the weight exponentially higher for every 4000 health over 4000.
			for(i = 0; i < maxTier; i++)
			{
				int scale = FixedDiv(Health << 16, 4000.0);
				int newWeight = FixedMul((tierWeights[i]*tierWeights[i]) << 16, scale) >> 16;
				if(newWeight < 1)
					newWeight = 1;
				tierWeights[i] = newWeight;
				totalWeight += newWeight;
			}

			if(GetCVar("sh_debug_boxes"))
				log(s:"DEBUG: Tier weights - ", d:tierWeights[0], s:", ", d:tierWeights[1], s:", ", d:tierWeights[2], s:", ", d:tierWeights[3], s:", ", d:tierWeights[4]);

			int rnd = random(0, totalWeight-1);
			for(i=0; i < maxTier; i++)
			{
				int weight = tierWeights[i];
				if(rnd < weight)
				{
					int boxTID = UniqueTID (0, 0);
					SpawnForced("ActiveBox1", GetActorX(0), GetActorY(0), GetActorZ(0)+(Height/2), boxTID, random(0, 255));
					SetUserVariable(boxTID, "user_tier", i+1);

					HudMessageBold(s:"A tier ", d:i+1, s:" MannCo box was dropped by ", s:(startsWithVowel(StrParam(n:0))) ? "an " : "a ", n:0, s:"!\n\cjWhat will you get?!";
					HUDMSG_TYPEON | HUDMSG_LOG, 70, CR_GOLD, 320.4, 128.1, 30.0, 0.01, 0.5);
					break;
				}
				rnd -= weight;
			}
		}
	}

	SetActivatorToTarget(0); // Set activator to the one who killed this monster.

	if(GetCVar("sh_debug_orbs"))
		log(s:"DEBUG: ", n:0, s:" killed ", s:Class, s:" [", d:Health, s:"] ", s:"Orbs: ", d:NumOrbs);
}

// Damage Numbers
// --------------
// This is code ported over from SMMP, another one of my projects.
function int pow (int x, int n)
{
	int y = 1;
	while (n-- > 0) y *= x;
	return y;
}

function int GetDigit(int Num, int Digit)
{
	return (Num / pow(10, Digit)) % 10 ;
}

function void PrintDamage(int damage)
{
	if(damage > 9999)
		damage = 9999;

	int Digit1 = GetDigit(damage, 0);
	int Digit2 = GetDigit(damage, 1);
	int Digit3 = GetDigit(damage, 2);
	int Digit4 = GetDigit(damage, 3);

	int height = GetActorProperty(0, APROP_Height);
	if(GetActorProperty(0, APROP_Health) <= 0)
		height *= 4;

	int x = GetActorX(0) + Random(-10.0, 10.0);
	int y = GetActorY(0) + Random(-10.0, 10.0);
	int z = GetActorZ(0) + height + Random(-10.0, 5.0);

	int ceilingZ = GetActorCeilingZ(0);
	if(z+10.0 >= ceilingZ)
		z = (ceilingZ-10.0) + Random(-10.0, 0.0);

	int TranslationNumber = Random(6000, 6007);

	int NumberID = Random(6000, 6500);

	if(Digit1 == 0) { Spawn("Digit1Num0", x, y, z, NumberID, 0); }
	else if(Digit1 == 1) { Spawn("Digit1Num1", x, y, z, NumberID, 0); }
	else if(Digit1 == 2) { Spawn("Digit1Num2", x, y, z, NumberID, 0); }
	else if(Digit1 == 3) { Spawn("Digit1Num3", x, y, z, NumberID, 0); }
	else if(Digit1 == 4) { Spawn("Digit1Num4", x, y, z, NumberID, 0); }
	else if(Digit1 == 5) { Spawn("Digit1Num5", x, y, z, NumberID, 0); }
	else if(Digit1 == 6) { Spawn("Digit1Num6", x, y, z, NumberID, 0); }
	else if(Digit1 == 7) { Spawn("Digit1Num7", x, y, z, NumberID, 0); }
	else if(Digit1 == 8) { Spawn("Digit1Num8", x, y, z, NumberID, 0); }
	else if(Digit1 == 9) { Spawn("Digit1Num9", x, y, z, NumberID, 0); }

	if(damage >= 10)
	{
		if(Digit2 == 0) { Spawn("Digit2Num0", x, y, z, NumberID, 0); }
		else if(Digit2 == 1) { Spawn("Digit2Num1", x, y, z, NumberID, 0); }
		else if(Digit2 == 2) { Spawn("Digit2Num2", x, y, z, NumberID, 0); }
		else if(Digit2 == 3) { Spawn("Digit2Num3", x, y, z, NumberID, 0); }
		else if(Digit2 == 4) { Spawn("Digit2Num4", x, y, z, NumberID, 0); }
		else if(Digit2 == 5) { Spawn("Digit2Num5", x, y, z, NumberID, 0); }
		else if(Digit2 == 6) { Spawn("Digit2Num6", x, y, z, NumberID, 0); }
		else if(Digit2 == 7) { Spawn("Digit2Num7", x, y, z, NumberID, 0); }
		else if(Digit2 == 8) { Spawn("Digit2Num8", x, y, z, NumberID, 0); }
		else if(Digit2 == 9) { Spawn("Digit2Num9", x, y, z, NumberID, 0); }
	}

	if(damage >= 100)
	{
		if(Digit3 == 0) { Spawn("Digit3Num0", x, y, z, NumberID, 0); }
		else if(Digit3 == 1) { Spawn("Digit3Num1", x, y, z, NumberID, 0); }
		else if(Digit3 == 2) { Spawn("Digit3Num2", x, y, z, NumberID, 0); }
		else if(Digit3 == 3) { Spawn("Digit3Num3", x, y, z, NumberID, 0); }
		else if(Digit3 == 4) { Spawn("Digit3Num4", x, y, z, NumberID, 0); }
		else if(Digit3 == 5) { Spawn("Digit3Num5", x, y, z, NumberID, 0); }
		else if(Digit3 == 6) { Spawn("Digit3Num6", x, y, z, NumberID, 0); }
		else if(Digit3 == 7) { Spawn("Digit3Num7", x, y, z, NumberID, 0); }
		else if(Digit3 == 8) { Spawn("Digit3Num8", x, y, z, NumberID, 0); }
		else if(Digit3 == 9) { Spawn("Digit3Num9", x, y, z, NumberID, 0); }
	}

	if(damage >= 1000)
	{
		if(Digit4 == 0) { Spawn("Digit4Num0", x, y, z, NumberID, 0); }
		else if(Digit4 == 1) { Spawn("Digit4Num1", x, y, z, NumberID, 0); }
		else if(Digit4 == 2) { Spawn("Digit4Num2", x, y, z, NumberID, 0); }
		else if(Digit4 == 3) { Spawn("Digit4Num3", x, y, z, NumberID, 0); }
		else if(Digit4 == 4) { Spawn("Digit4Num4", x, y, z, NumberID, 0); }
		else if(Digit4 == 5) { Spawn("Digit4Num5", x, y, z, NumberID, 0); }
		else if(Digit4 == 6) { Spawn("Digit4Num6", x, y, z, NumberID, 0); }
		else if(Digit4 == 7) { Spawn("Digit4Num7", x, y, z, NumberID, 0); }
		else if(Digit4 == 8) { Spawn("Digit4Num8", x, y, z, NumberID, 0); }
		else if(Digit4 == 9) { Spawn("Digit4Num9", x, y, z, NumberID, 0); }
	}

	Thing_SetTranslation(NumberID, TranslationNumber);
	SetActorVelocity(NumberID, 0, 0, 0.25, 0, 0);

	return;
}

script "GENERATE_DMG_TRANSLATIONS" OPEN
{
	CreateTranslation(6001, 160:160=[255, 0, 0]:[255, 0, 0]); // Red
	CreateTranslation(6002, 160:160=[0, 255, 0]:[0, 255, 0]); // Green
	CreateTranslation(6003, 160:160=[0, 0, 255]:[0, 0, 255]); // Blue
	CreateTranslation(6004, 160:160=[255, 255, 0]:[255, 255, 0]); // Yellow
	CreateTranslation(6005, 160:160=[0, 255, 255]:[0, 255, 255]); // Cyan
	CreateTranslation(6006, 160:160=[255, 0, 255]:[255, 0, 255]); // Magenta
	CreateTranslation(6007, 160:160=[255, 255, 255]:[255, 255, 255]); // White
}

#define HIT_OTHER 0
#define HIT_FLESH 1

function void hit_marker(int soundType, bool friendly)
{
	if(friendly)
		LocalAmbientSound("hitsound_friend", 64);
	else
	{
		switch(soundType)
		{
			case HIT_FLESH:
				LocalAmbientSound("hitsound_flesh", 64);
				break;
			default:
				LocalAmbientSound("hitsound_generic", 32);
				break;
		}
	}

	SetHudSize(1024, 768, 0);
	int id = 6969;
	if(!friendly)
		SetFont("HITMARK");
	else
	{
		id = 6970;
		SetFont("HITFREN");
	}
	HudMessage(s:"A";
	HUDMSG_FADEOUT, id, CR_UNTRANSLATED, 512.4, 384.0, 1, 0.5);

	return;
}

function void actor_swap(str replace, str with, int chance)
{
	if(!CheckActorClass(0, replace))
		return;

	if((chance >= 255) || (random(0, 255) < chance))
	{
		int thisTID = ActivatorTID();
		int uTID = UniqueTID();
		int xvel = GetActorVelX(0);
		int yvel = GetActorVelY(0);
		int zvel = GetActorVelZ(0);
		bool dropped = CheckFlag(0, "DROPPED");
		bool ambush = CheckFlag(0, "AMBUSH");
		bool friendly = CheckFlag(0, "FRIENDLY");
		bool stealth = CheckFlag(0, "STEALTH");
		bool standstill = CheckFlag(0, "STANDSTILL");
		bool dormant = CheckFlag(0, "DORMANT");

		SpawnForced(with, GetActorX(0), GetActorY(0), GetActorZ(0), uTID, GetActorAngle(0));
		SetActorVelocity(uTID, xvel, yvel, zvel, false, false);

		SetActorProperty(uTID, APROP_Ambush, ambush); // ChangeActorFlag(uTID, "AMBUSH", ambush);
		SetActorProperty(uTID, APROP_Dormant, dormant); // ChangeActorFlag(uTID, "DORMANT", dormant);
		ChangeActorFlag(uTID, "DROPPED", dropped);
		ChangeActorFlag(uTID, "FRIENDLY", friendly);
		ChangeActorFlag(uTID, "STEALTH", stealth);
		ChangeActorFlag(uTID, "STANDSTILL", standstill);

		if(GetCVar("sh_debug_spawns"))
			log(s:replace, s:"(TID: ", d:thisTID, s:") has been swapped with ", s:with);

		// These must be last!
		Thing_ChangeTID(uTID, thisTID);
		Thing_Remove(0);
	}

	return;
}

// [JM] These defs are missing from ACC for some buttfuckin' reason.
/*
#define GAMEEVENT_PLAYERFRAGS			0
#define GAMEEVENT_MEDALS				1
#define GAMEEVENT_CAPTURES				2
#define GAMEEVENT_TOUCHES				3
#define GAMEEVENT_RETURNS				4
#define GAMEEVENT_ROUND_STARTS			5
#define GAMEEVENT_ROUND_ENDS			6
#define GAMEEVENT_ROUND_ABORTED			7
#define GAMEEVENT_CHAT					8
#define GAMEEVENT_PLAYERCONNECT			9
#define GAMEEVENT_ACTOR_SPAWNED			10
#define GAMEEVENT_ACTOR_DAMAGED			11
#define GAMEEVENT_ACTOR_ARMORDAMAGED	12
#define GAMEEVENT_DOMINATION_CONTROL	13
#define GAMEEVENT_DOMINATION_POINT		14
#define GAMEEVENT_PLAYERLEAVESSERVER	15
*/

#define ONE_16 (1<<16)

function int handle_damage_event(int type, int arg1, int arg2)
{
	// -------------
	int fixedDamage;	// Damage as a fixed-point value. Re-initialized and re-used in multiple places.
	int yeetAmt;		// Vertical push.
	// -------------

	int victimPlayerNum = PlayerNumber();
	bool victimIsMonster = CheckFlag(0, "ISMONSTER");
	bool victimCanBleed = !CheckFlag(0, "NOBLOOD");
	bool victimIsFriendly = (CheckFlag(0, "FRIENDLY") || (victimPlayerNum != -1));

	bool doTeamDamageScale = false;
	bool directMonsterDamage = false;
	bool wasConcussed = false;
	bool wasTelefrag = (!StrIcmp(arg2, "spawntelefrag") || !StrIcmp(arg2, "telefrag"));
	
	str inflictorClass = "Unknown";
	
	if(SetActivator(0, AAPTR_DAMAGE_INFLICTOR))
	{
		directMonsterDamage = CheckFlag(0, "ISMONSTER");
		inflictorClass = GetActorClass(0);

		// Damage Falloff Calc = fix16(basedamage) - (fix16(falloff) * tics/rate) >> 16
		int falloffAmt = GetUserVariable(0, "user_falloff");
		if(falloffAmt > 0) // Falloff calc for Max's blaster bolts.
		{
			int falloffRate = GetUserVariable(0, "user_falloffrate");
			if(falloffRate <= 0)
				falloffRate = 1;

			fixedDamage = arg1 << 16;
			int minDamage = GetUserVariable(0, "user_mindmg");
			int falloffTics = GetUserVariable(0, "user_fallofftics");

			arg1 = (fixedDamage - (falloffAmt * (falloffTics/falloffRate))) >> 16;

			if(arg1 < minDamage)
				arg1 = minDamage;
		}

		wasConcussed = CheckActorClass(0, "ConcussionBlast");
		if(CheckActorClass(0, "FistPuff") || wasConcussed)
		{
			int yeetForceBase = arg1;
			yeetAmt = random(yeetForceBase >> 2, yeetForceBase);
		}

		if(GetCVar("sh_debug_damage"))
			log(s:"DEBUG: Entity damaged by ", s:GetActorClass(0));
	}

	if(SetActivator(0, AAPTR_DAMAGE_SOURCE))
	{
		int attackerPlayerNum = PlayerNumber();
		bool attackerIsMonster = CheckFlag(0, "ISMONSTER");
		bool attackerIsFriendly = (CheckFlag(0, "FRIENDLY") || (attackerPlayerNum != -1));

		if(attackerPlayerNum != -1) // Source is player
		{
			if(victimIsMonster || (victimIsFriendly && victimPlayerNum != attackerPlayerNum))
				hit_marker(victimCanBleed ? HIT_FLESH : HIT_OTHER, victimIsFriendly);

			// Gosimer's Berserk Buff
			if(CheckActorClass(0, "Gosimer") && CheckInventory("PowerStrength"))
				arg1 += 1;

			if(victimIsMonster && victimIsFriendly) // Player hitting friendly monster.
				doTeamDamageScale = true;
		}
		else if(attackerIsMonster) // Source is a monster.
		{
			if(attackerIsFriendly && victimPlayerNum != -1) // Friendly monster hitting player.
				doTeamDamageScale = true;
		}

		if(GetCVar("sh_friendly_scaledamage") && doTeamDamageScale && !wasTelefrag)
		{
			int teamDamage = GetCvar("teamdamage");
			fixedDamage = arg1 << 16;
			arg1 = FixedMul(fixedDamage, teamDamage) >> 16;
		}
	}

	if(SetActivator(0, AAPTR_DAMAGE_TARGET))
	{
		if(yeetAmt > 0 && !CheckFlag(0, "DONTBLAST"))
		{
			int assMass = GetActorProperty(0, APROP_Mass) >> 8;
			if(assMass <= 0)
				assMass = 1;

			if(assMass > 1)
			{
				yeetAmt /= assMass;
				if(yeetAmt <= 0)
					yeetAmt = 1; // We always do a little bit of yeeting.
			}

			if(!CheckFlag(0, "FLOAT"))
				ThrustThingZ(0, yeetAmt, 0, 1);

			if(wasConcussed && victimIsMonster)
				ChangeFlag("BLASTED", true);
		}

		if(wasConcussed)
			SpawnForced("ConcussionExtra", GetActorX(0), GetActorY(0), GetActorZ(0), 0, GetActorAngle(0));
		
		if(victimIsMonster && victimCanBleed)
		{
			if(!StrIcmp(inflictorClass, "GoldCryoShot"))
				GiveInventory("KunaisLifeStealingItem", 1);
		}

		if(victimPlayerNum != -1)
		{
			// These inventory items provide invulnerability.
			if(
				CheckInventory("PowerInvulnerable") ||
				CheckInventory("PowerSpawnProtection") ||
				CheckInventory("PowerFiendUlt") ||
				CheckInventory("PowerKanKan")
			)
			{
				return 0;
			}
	
			if(CheckActorClass(0, "MaximusPrime"))
			{
				if(directMonsterDamage) // Reduce Melee Damage
				{
					fixedDamage = fixedmul(arg1<<16, 0.78);
					arg1 = fixedDamage>>16;
					if(arg1 < 1)
						arg1 = 1;
				}

				// Monster melee passes through shields.
				if(CheckInventory("BasicArmor") > 0 && !directMonsterDamage)
				{
					// [JM] Credit to Lucius for "The Force Engine" code referenced/ported here.
					fixedDamage = arg1 << 16;
					int shields = CheckInventory("BasicArmor") << 16;
					int healthDmg = 0;

					// The amount of shield energy left after taking *half* damage.
					int halfShieldDmg = fixedDamage >> 1;
					shields = max(0, shields - halfShieldDmg);

					if (shields < (50<<16))
					{
						// healthDmg += shieldDmg * (1 - shields/50.0)
						int fracDmgToHealth = ONE_16 - fixeddiv(shields, (50<<16));
						healthDmg += fixedmul(fracDmgToHealth, fixedDamage);
					}

					// Now take the other half away.
					shields = max(0, shields - halfShieldDmg);
					TakeInventory("BasicArmor", 99999);
					GiveInventory("NullArmorHack", shields>>16);

					arg1 = healthDmg>>16;
					ActivatorSound("Max/ShieldDamage", 127);

					FadeRange (0, 255, 0, min(fixedmul(fixedDamage, 0.01), 1.0), 0, 255, 0, 0.0, 0.5);
				}
			}
		}
	}

	return arg1;
}

function void multiply_actor(int mult)
{
	int radius = GetActorProperty(0, APROP_Radius)*2;
	int pos[4] = { GetActorX(0), GetActorY(0), GetActorZ(0), GetActorAngle(0)>>8 };
	bool ambush = CheckFlag(0, "AMBUSH");
	bool friendly = CheckFlag(0, "FRIENDLY");
	bool stealth = CheckFlag(0, "STEALTH");
	bool standstill = CheckFlag(0, "STANDSTILL");
	bool dormant = CheckFlag(0, "DORMANT");

	int enemyCount = 1;
	int dir = 0;
	int stride = 1;
	int stride_cycle = 0;
	int spawnAttempts = 0;

	if(GetCVar("sh_debug_spawns"))
		log(s:"Multiplying ", s:GetActorClass(0), s:" (Ambush: ", d:ambush, s:")");

	do
	{
		int iter = 0;

		do
		{
			iter++;
			switch (dir)
			{
				case 0: pos[1] += radius; break;
				case 1: pos[0] += radius; break;
				case 2: pos[1] -= radius; break;
				case 3: pos[0] -= radius; break;
			}

			int newFloorZ = GetSectorFloorZ(0, pos[0]>>16, pos[1]>>16);
			int floorZDiff = abs(pos[2] - newFloorZ);
			int beaconTID = UniqueTID(0);

			bool floorZPassed = (floorZDiff <= 64.0);
			bool sightPassed = false;
			int spawnPassed = false;

			if(floorZPassed)
			{
				if(Spawn("SightCheckBeacon", pos[0], pos[1], newFloorZ, beaconTID, 0))
				{
					sightPassed = CheckSight(0, beaconTID, 0);
					if(sightPassed)
					{
						int thisTID = ActivatorTID();
						int uTID = UniqueTID(0);

						spawnPassed = Spawn(GetActorClass(0), pos[0], pos[1], newFloorZ, uTID, pos[3]);

						if(spawnPassed)
						{
							SetActorProperty(uTID, APROP_Ambush, ambush); // ChangeActorFlag(uTID, "AMBUSH", ambush);
							SetActorProperty(uTID, APROP_Dormant, dormant); // ChangeActorFlag(uTID, "DORMANT", dormant);
							SetActorProperty(uTID, APROP_ReactionTime, random(8, 14));

							ChangeActorFlag(uTID, "FRIENDLY", friendly);
							ChangeActorFlag(uTID, "STEALTH", stealth);
							ChangeActorFlag(uTID, "STANDSTILL", standstill);
							ChangeActorFlag(uTID, "DROPPED", 0);

							Thing_ChangeTID(uTID, thisTID);
						}
					}
				}
			}

			if(!floorZPassed || !sightPassed || !spawnPassed)
			{
				spawnAttempts++;
				if(spawnAttempts >= 25)
				{
					if(GetCVar("sh_debug_spawns"))
						log(s:"Giving up after too many attempts to spawn.");

					enemyCount = mult;
					break;
				}

				continue;
			}

			spawnAttempts = 0;
			enemyCount++;

			if(GetCVar("sh_debug_spawns"))
				log(s:"count: ", d:enemyCount, s:" iter: ", d:iter, s:" stride: ", d:stride, s:" z: ", f:pos[2], s:" floorz: ", f:GetSectorFloorZ(0, pos[0]>>16, pos[1]>>16));
		} while((iter < stride) && enemyCount < mult);

		dir = (dir+1)%4;
		stride_cycle++;
		if((stride_cycle % 2) == 0)
			stride++;
	} while(enemyCount < mult);
}

script "EVENT_HANDLER" (int type, int arg1, int arg2) EVENT
{
	switch (type)
	{
		case GAMEEVENT_ACTOR_ARMORDAMAGED:
		{
			arg1 = handle_damage_event(type, arg1, arg2);
			SetResultValue(arg1);
			break;
		}
		case GAMEEVENT_ACTOR_DAMAGED:
		{
			if(CheckFlag(0, "ISMONSTER"))
			{
				GiveInventory("DamageTallyHack", arg1);
				delay(1);
				int damage = CheckInventory("DamageTallyHack");
				if(damage > 0)
				{
					PrintDamage(damage);
					TakeInventory("DamageTallyHack", 9999);
				}
			}
			break;
		}
		case GAMEEVENT_ACTOR_SPAWNED:
		{
			if((GetCVar("sh_enemy_mult") > 1) && arg1 == true && CheckFlag(0, "ISMONSTER"))
				multiply_actor(clamp(GetCVar("sh_enemy_mult"), 2, 100));

			if(GetCVar("sh_compat_swaps"))
			{
				// Strange Aeons compatibility swaps
				actor_swap("AK47", "ChaingunGiver", 256);
				actor_swap("Yithgun", "PlasmaRifleGiver", 256);
				actor_swap("ImpalerXBow", "Railgundrop", 256);
				actor_swap("Devil", "Imps", 64);
				actor_swap("RapidFireTrooper", "Zamble", 64);
				actor_swap("UndeadHunter", "Shootgunzamble", 64);
				actor_swap("Skeleton", "MeleeRevenant", 64);
				actor_swap("HellWarrior", "BaronSpawner", 64);
				actor_swap("SlimeWorm", "JIHADReplacer", 64);
			}
			break;
		}
	}
}

#define AMMO_CLIP		0
#define AMMO_CLIPBOX	1
#define AMMO_SHELLS		2
#define AMMO_SHELLBOX	3
#define AMMO_ROCKET		4
#define AMMO_ROCKETBOX	5
#define AMMO_CELL		6
#define AMMO_CELLBOX	7

#define DROPTYPE_NONE 0
#define DROPTYPE_HALVED 1
#define DROPTYPE_FULL 2
#define DROPTYPE_RANDOM 3

// Brutal shitfuck hack due to Zandronum not networking the "log" command for some buttfuck reason.
// Use with "NamedSendNetworkString".
script "LOGMESSAGE_HACK" (int msg) CLIENTSIDE
{
	log(s:msg);
}

// Gives ammo to player.
// return value is how much was really given after doubling or accounting for capacity.
function int add_ammo(str ammo_class, int amount, int droptype)
{
	if(amount == 0)
		return 0;

	if(GetCvar("sh_ammo_mult") > 1)
		amount *= GetCvar("sh_ammo_mult");
	else if((GameSkill() == 0) || (GameSkill() == 4) || GetCvar("sv_doubleammo"))
		amount *= 2;

	switch(droptype)
	{
		case DROPTYPE_HALVED:
		{
			amount /= 2;
			if(amount == 0)
				amount = 1;
			break;
		}
		case DROPTYPE_RANDOM:
		{
			amount = random(amount>>1, amount);
			if(amount == 0)
				amount = 1;
			break;
		}
	}

	if(StrIcmp(ammo_class, "None") != 0 && amount > 0)
	{
		if(CheckInventory(ammo_class) < GetAmmoCapacity(ammo_class))
		{
			// Adjust ammo given to remainder of capacity, if applicable.
			// Doing this so I can pass the real amount gained to the pickup message.
			if((CheckInventory(ammo_class) + amount) > GetAmmoCapacity(ammo_class))
				amount = GetAmmoCapacity(ammo_class) - CheckInventory(ammo_class);

			GiveInventory(ammo_class, amount);
			return amount;
		}
	}

	return 0;
}

script 13236 (int type, int dropped) // "AMMO_PICKUP"
{
	SetResultValue(0); // Starting result should always be 0, only set to 1 on success.
	if(IsNetworkGame() && (ConsolePlayerNumber() != -1)) // Hack to prevent Zandronum from executing this on a client
		terminate;

	str ammo1_class = "None";
	str ammo1_name = "None";
	int ammo1_amount = 0;

	str ammo2_class = "None";
	str ammo2_name = "None";
	int ammo2_amount = 0;

	str pickupsound = "misc/i_pkup";
	str extrasound = "None";
	str textcolor = "\cf";

	int droptype = DROPTYPE_HALVED;

	int fade_rgb[3] = { 255, 192, 0 };

	// Our ammo types. Determined by a numerical index passed to the script.
	switch(type)
	{
		case AMMO_CLIP:
		{
			ammo1_class = "PeastolClip";
			ammo1_amount = 12;

			if(CheckActorClass(0, "MaximusPrime"))
			{
				droptype = DROPTYPE_FULL;
				ammo1_class = "DF_EnergyUnit";
				ammo1_amount = 15;
			}
			else if(CheckActorClass(0, "Gosimer"))
			{
				droptype = DROPTYPE_RANDOM;
			}

			pickupsound = "AMMO/CLIP";
			break;
		}
		case AMMO_CLIPBOX:
		{
			ammo1_class = "AK_MAG";
			ammo1_amount = 75;

			if(CheckActorClass(0, "MaximusPrime"))
			{
				droptype = DROPTYPE_FULL;
				ammo1_class = "DF_EnergyUnit";
				ammo1_amount = 45;
			}
			else if(CheckActorClass(0, "Fiend"))
			{
				extrasound = "Jim/taunt10";
			}

			pickupsound = "AMMO/CLIP";
			break;
		}
		case AMMO_SHELLS:
		{
			ammo1_class = "Shellz";
			ammo1_amount = 2;

			if(CheckActorClass(0, "MaximusPrime"))
			{
				droptype = DROPTYPE_FULL;
				ammo1_class = "DF_PowerCell";
				ammo1_amount = 10;
			}
			else
			{
				ammo2_class = "Supershellz";
				ammo2_amount = 2;
			}

			pickupsound = "AMMO/SHEL";
			break;
		}
		case AMMO_SHELLBOX:
		{
			ammo1_class = "Shellz";
			ammo1_amount = 10;

			if(CheckActorClass(0, "MaximusPrime"))
			{
				droptype = DROPTYPE_FULL;
				ammo1_class = "DF_PowerCell";
				ammo1_amount = 30;
			}
			else
			{
				ammo2_class = "Supershellz";
				ammo2_amount = 10;
			}

			pickupsound = "AMMO/SHELBAWX";
			break;
		}
		case AMMO_ROCKET:
		{
			ammo1_class = "Roketammo";
			ammo1_amount = 1;

			if(CheckActorClass(0, "MaximusPrime"))
			{
				droptype = DROPTYPE_FULL;
				ammo1_name = "Mortar Shell";
			}
			else if(CheckActorClass(0, "Gosimer"))
			{
				ammo1_name = "Grenade";
			}

			pickupsound = "AMMO/ROKET";
			break;
		}
		case AMMO_ROCKETBOX:
		{
			ammo1_class = "Roketammo";
			ammo1_amount = 5;

			if(CheckActorClass(0, "MaximusPrime"))
			{
				droptype = DROPTYPE_FULL;
				ammo1_name = "Mortar Shell";
			}
			else if(CheckActorClass(0, "Gosimer"))
			{
				ammo1_name = "Grenade";
			}

			pickupsound = "AMMO/ROKETBAWX";
			break;
		}
		case AMMO_CELL:
		{
			ammo1_class = "Battery";
			ammo1_amount = 40;

			ammo2_class = "RailSLUGS";
			ammo2_amount = 6;

			if(CheckActorClass(0, "MaximusPrime"))
			{
				droptype = DROPTYPE_FULL;
				ammo1_class = "DF_PlasmaCartridge";
				ammo1_amount = 20;

				ammo2_name = "Disruptor Cell";
			}
			else if(CheckActorClass(0, "Fiend"))
			{
				extrasound = "Jim/taunt6";
			}

			pickupsound = "AMMO/BATTERY";
			break;
		}
		case AMMO_CELLBOX:
		{
			ammo1_class = "Battery";
			ammo1_amount = 100;

			ammo2_class = "BFGCHARGE";
			ammo2_amount = 2;

			// Todo: Lightning Ammo.

			if(CheckActorClass(0, "MaximusPrime"))
			{
				droptype = DROPTYPE_FULL;
				ammo1_class = "DF_Missile";
				ammo1_amount = 5;

				ammo2_class = "DF_PlasmaCartridge";
				ammo2_amount = 60;
			}
			else if(CheckActorClass(0, "Gosimer"))
			{
				ammo2_class = "DevastatorAmmo";
				ammo2_amount = 50;
			}
			else if(CheckActorClass(0, "Fiend"))
			{
				extrasound = "Jim/taunt4";
			}

			pickupsound = "AMMO/BATTERYPAK";
			break;
		}
	}

	if(!dropped)
		droptype = DROPTYPE_NONE;

	ammo1_amount = add_ammo(ammo1_class, ammo1_amount, droptype);
	ammo2_amount = add_ammo(ammo2_class, ammo2_amount, droptype);
	bool success = (ammo1_amount || ammo2_amount);

	if(success)
	{
		// If name isn't overridden, use ammo's tag.
		if(!StrIcmp(ammo1_name, "None"))
			ammo1_name = GetClassTag(ammo1_class);
		if(!StrIcmp(ammo2_name, "None"))
			ammo2_name = GetClassTag(ammo2_class);

		str suffix1 = "";
		str suffix2 = "";

		// Add a plural suffix, if applicable.
		if((ammo1_amount) > 1)
			suffix1 = "s";
		if ((ammo2_amount) > 1)
			suffix2 = "s";

		if(CheckActorClass(0, "MaximusPrime"))
		{
			textcolor = "\ci";
			fade_rgb[0] = 0;
			fade_rgb[1] = 0;
			fade_rgb[2] = 255;
		}

		str msg = StrParam(s:textcolor);
		if(ammo1_amount > 0)
		{
			msg = StrParam(s:msg, d:ammo1_amount, s:" ", s:ammo1_name, s:suffix1);
			if(ammo2_amount > 0)
				msg = StrParam(s:msg, s:" & ");
		}

		if(ammo2_amount > 0)
		{
			msg = StrParam(s:msg, d:ammo2_amount, s:" ", s:ammo2_name, s:suffix2);
		}

		NamedSendNetworkString("LOGMESSAGE_HACK", msg, PlayerNumber());

		//if(ammo1_amount > 0 && ammo2_amount > 0)
			//log(s:textcolor, d:ammo1_amount, s:" ", s:ammo1_name, s:suffix1, s:" & ", d:ammo2_amount, s:" ", s:ammo2_name, s:suffix2);
		//else if(ammo1_amount > 0)
			//log(s:textcolor, d:ammo1_amount, s:" ", s:ammo1_name, s:suffix1);

		PlaySound(0, pickupsound, CHAN_ITEM, 1.0, false);
		if(StrIcmp(extrasound, "None") != 0)
			PlaySound(0, extrasound, CHAN_6, 1.0, false);

		FadeRange (fade_rgb[0], fade_rgb[1], fade_rgb[2], 0.25, fade_rgb[0], fade_rgb[1], fade_rgb[2], 0.0, 0.25);

		SetResultValue(1);
	}
}

// ------------------
// Weapon Pickup Code
// ------------------

#define WEAPON_CHAINSAW		0
#define WEAPON_PISTOL		1
#define WEAPON_SHOTGUN		2
#define WEAPON_SSG			3
#define WEAPON_CHAINGUN		4
#define WEAPON_ROCKET		5
#define WEAPON_PLASMA		6
#define WEAPON_BFG			7
#define WEAPON_RAILGUN		8
#define WEAPON_FLAME		9
#define WEAPON_NUKE			10

// Unfinished...

script 13237 (int type, int dropped) // "WEAPON_PICKUP"
{
	SetResultValue(0); // Starting result should always be 0, only set to 1 on success.
	if(IsNetworkGame() && (ConsolePlayerNumber() != -1)) // Hack to prevent Zandronum from executing this on a client
		terminate;

	str weapon_class = "None";
	str pickupsound = "misc/w_pkup";
	str pickupsound_new = "None";

	str ammo1_class = "None";
	str ammo2_class = "None";

	str ammo1_name = "None";
	str ammo2_name = "None";

	str weapontextcolor = "\cd";
	str ammotextcolor = "\cf";

	int ammo1_amount = 0;
	int ammo2_amount = 0;

	int droptype = DROPTYPE_HALVED;

	int tier = 0;

	int fade_rgb[3] = { 255, 192, 0 };

	if(CheckActorClass(0, "MaximusPrime"))
	{
		pickupsound = "Max/HealthBonus";
		droptype = DROPTYPE_FULL;
	}

	switch(type)
	{
		case WEAPON_CHAINSAW:
		case WEAPON_PISTOL:
			SetResultValue(0);  // Unused, for now.
			terminate;
			break;

		case WEAPON_SHOTGUN:
		{
			weapon_class = "D3Shotgun";
			ammo1_class = "Shellz";
			ammo1_amount = 12;

			if(CheckActorClass(0, "Fiend"))
			{
				pickupsound_new = "weapon/singleget";
			}
			else if(CheckActorClass(0, "Kunai"))
			{
				weapon_class = "HelltechShotgun";
				ammo1_amount = 8;
			}
			else if(CheckActorClass(0, "Gosimer"))
			{
				weapon_class = "CombatShotgun";
				ammo1_amount = 8;
			}
			else if(CheckActorClass(0, "MaximusPrime"))
			{
				if(!dropped)
				{
					weapon_class = "Autogun";
					ammo1_class = "DF_PowerCell";
					ammo1_amount = 30;
				}
				else
				{
					weapon_class = "DFBlaster";
					ammo1_class = "DF_EnergyUnit";
					ammo1_amount = 15;
				}
			}
			break;
		}

		case WEAPON_SSG:
		{
			weapon_class = "SuperShawtgun";
			ammo1_class = "SuperShellz";
			ammo1_amount = 8;

			if(CheckActorClass(0, "Fiend"))
			{
				pickupsound_new = "weapon/Fssgget";
			}
			else if(CheckActorClass(0, "Kunai"))
			{
				pickupsound_new = "weapon/StreetsweeperGet";
				weapon_class = "Streetsweeper";
				ammo1_amount = 20;
			}
			else if(CheckActorClass(0, "Gosimer"))
			{
				pickupsound_new = "Weapon/Protoget";
				weapon_class = "BurstShotgun";
				ammo1_amount = 24;
			}
			else if(CheckActorClass(0, "MaximusPrime"))
			{
				weapon_class = "FusionCutter";
				ammo1_class = "DF_PowerCell";
				ammo1_amount = 50;
			}

			break;
		}

		case WEAPON_CHAINGUN:
		{
			weapon_class = "D3Chaingun";
			ammo1_class = "AK_Mag";
			ammo1_amount = 20;

			if(CheckActorClass(0, "Fiend"))
			{
				pickupsound_new = "Weapon/Miniget";
			}
			else if(CheckActorClass(0, "Kunai"))
			{
				pickupsound_new = "Weapon/lmgget";
				weapon_class = "PDW";
				ammo1_amount = 50;
			}
			else if(CheckActorClass(0, "Gosimer"))
			{
				pickupsound_new = "Weapon/Ripperget";
				weapon_class = "HMachinegun";
				ammo1_amount = 50;
			}
			else if(CheckActorClass(0, "MaximusPrime"))
			{
				if(!dropped)
				{
					weapon_class = "DFBlaster";
					ammo1_class = "DF_EnergyUnit";
					ammo1_amount = 15;
				}
				else
				{
					weapon_class = "Autogun";
					ammo1_class = "DF_PowerCell";
					ammo1_amount = 30;
				}
			}

			break;
		}

		case WEAPON_ROCKET:
		{
			weapon_class = "Rawketlawnchair";
			ammo1_class = "RoketAmmo";
			ammo1_amount = 5;

			if(CheckActorClass(0, "Fiend"))
			{
				pickupsound_new = "Weapon/Rocketget";
			}
			else if(CheckActorClass(0, "Kunai"))
			{
				pickupsound_new = "Weapon/Bowget";
				weapon_class = "Cryobow";
				ammo1_amount = 5;
			}
			else if(CheckActorClass(0, "Gosimer"))
			{
				pickupsound_new = "Weapon/Nadeget";
				weapon_class = "BoomToob";
				ammo1_amount = 10;
			}
			else if(CheckActorClass(0, "MaximusPrime"))
			{
				weapon_class = "MortarGun";
				ammo1_amount = 3;
			}
			break;
		}

		case WEAPON_PLASMA:
		{
			weapon_class = "DEPlasmaRifle";
			ammo1_class = "Battery";
			ammo1_amount = 40;

			if(CheckActorClass(0, "Fiend"))
			{
				pickupsound_new = "weapon/Plasmaget";
			}
			else if(CheckActorClass(0, "Kunai"))
			{
				pickupsound_new = "Weapon/ChannlerGet";
				weapon_class = "Channeler";
				ammo1_amount = 40;
			}
			else if(CheckActorClass(0, "Gosimer"))
			{
				pickupsound_new = "Weapon/thunderboltget";
				weapon_class = "Lightning_Rifle";
				ammo1_amount = 40;
			}
			else if(CheckActorClass(0, "MaximusPrime"))
			{
				weapon_class = "ConcRifle";
				ammo1_class = "DF_PowerCell";
				ammo1_amount = 100;
			}
			break;
		}
		
		case WEAPON_BFG:
		{
			weapon_class = "debfg9500";
			ammo1_class = "bfgcharge";
			ammo1_amount = 1;

			if(CheckActorClass(0, "Fiend"))
			{
				pickupsound_new = "weapon/bfgget";
			}
			else if(CheckActorClass(0, "Kunai"))
			{
				pickupsound_new = "Weapon/Vortexget";
				weapon_class = "Vortexgun";
				ammo1_amount = 2;
			}
			else if(CheckActorClass(0, "Gosimer"))
			{
				pickupsound_new = "Weapon/devistatorget";
				weapon_class = "micro_Devistator";
				ammo1_class = "DevastatorAmmo";
				ammo1_amount = 60;
			}
			else if(CheckActorClass(0, "MaximusPrime"))
			{
				weapon_class = "AssaultCannon";
				ammo1_class = "DF_PlasmaCartridge";
				ammo1_amount = 30;
				ammo2_class = "DF_Missile";
				ammo2_amount = 2;
			}
			break;
		}
	}

	if(!dropped)
	{
		droptype = DROPTYPE_NONE;
		// If weapon is set to stay, and weapon already given.
		if(GetCVar("sv_weaponstay") && CheckInventory(weapon_class))
			terminate;
	}

	ammo1_amount = add_ammo(ammo1_class, ammo1_amount, droptype);
	ammo2_amount = add_ammo(ammo2_class, ammo2_amount, droptype);
	bool success = (ammo1_amount || ammo2_amount || !CheckInventory(weapon_class));
	if(success)
	{
		bool isNew = false;
		if(!CheckInventory(weapon_class))
		{
			GiveInventory(weapon_class, 1);
			if(GetUserCVar(PlayerNumber(), "switchonpickup") > 1)
				SetWeapon(weapon_class);

			isNew = true;
		}

		// If name isn't overridden, use ammo's tag.
		if(!StrIcmp(ammo1_name, "None"))
			ammo1_name = GetClassTag(ammo1_class);
		if(!StrIcmp(ammo2_name, "None"))
			ammo2_name = GetClassTag(ammo2_class);

		str suffix1 = "";
		str suffix2 = "";

		// Add a plural suffix, if applicable.
		if((ammo1_amount) > 1)
			suffix1 = "s";
		if ((ammo2_amount) > 1)
			suffix2 = "s";

		if(CheckActorClass(0, "MaximusPrime"))
		{
			ammotextcolor = "\ci";
			fade_rgb[0] = 0;
			fade_rgb[1] = 0;
			fade_rgb[2] = 255;
		}

		str weapon_name = GetClassTag(weapon_class);

		str msg = StrParam(s:weapontextcolor, s:weapon_name);
		
		if(ammo1_amount > 0 || ammo2_amount > 0)
			msg = StrParam(s:msg, s:ammotextcolor, s:" (+");
			
		if(ammo1_amount > 0)
		{
			msg = StrParam(s:msg, d:ammo1_amount, s:" ", s:ammo1_name, s:suffix1);
			if(ammo2_amount > 0)
				msg = StrParam(s:msg, s:" & ");
		}

		if(ammo2_amount > 0)
		{
			msg = StrParam(s:msg, d:ammo2_amount, s:" ", s:ammo2_name, s:suffix2);
		}

		if(ammo1_amount || ammo2_amount)
			msg = StrParam(s:msg, s:")");

		NamedSendNetworkString("LOGMESSAGE_HACK", msg, PlayerNumber());

		if(isNew && (StrIcmp(pickupsound_new, "None") != 0))
			PlaySound(0, pickupsound_new, CHAN_ITEM, 1.0, false);
		else
			PlaySound(0, pickupsound, CHAN_ITEM, 1.0, false);

		FadeRange (fade_rgb[0], fade_rgb[1], fade_rgb[2], 0.25, fade_rgb[0], fade_rgb[1], fade_rgb[2], 0.0, 0.25);

		if(!GetCVar("sv_weaponstay") || dropped)
			SetResultValue(1);
	}
}

// --------------------------------

// --------------------------------
// Clientside Pickup Transformation
// --------------------------------

script "SET_PICKUP_SPRITE" (void) CLIENTSIDE
{
	if(ConsolePlayerNumber() == -1)
		terminate;

	int oldTID = ActivatorTID();
	int newTID = UniqueTID();
	Thing_ChangeTID(0, newTID);

	SetActivatorToPlayer(ConsolePlayerNumber());
	str playerClassName = GetActorClass(0);
	str scaleVar = StrParam(s:"user_scale_", s:playerClassName);

	SetActivator(newTID);
	SetActorState(0, "SetScale", false);

	bool stateSet = false;
	if(CheckFlag(0, "DROPPED"))
	{
		str droppedState = StrParam(s:playerClassName, s:"Dropped");
		stateSet = SetActorState(0, droppedState, false);
	}

	if(!stateSet)
		stateSet = SetActorState(0, playerClassName, false);

	if(!stateSet)
		SetActorState(0, "Base", false);

	// Hack to bypass the fact that Zan can't use A_SetScale from the client side on non-clientsided actors.
	if(GetUserVariable(0, scaleVar) > 0)
	{
		SetActorProperty(0, APROP_ScaleX, GetUserVariable(0, scaleVar)*0.01);
		SetActorProperty(0, APROP_ScaleY, GetUserVariable(0, scaleVar)*0.01);
	}
	else if(GetUserVariable(0, "user_scale_Base") > 0)
	{
		SetActorProperty(0, APROP_ScaleX, GetUserVariable(0, "user_scale_Base")*0.01);
		SetActorProperty(0, APROP_ScaleY, GetUserVariable(0, "user_scale_Base")*0.01);
	}

	Thing_ChangeTID(0, oldTID);
}

// -----------------------------

script "SUPERCHARGE_CHECK" (void)
{
	if(CheckInventory("PowerDoubleFiringSpeed"))
	{
		SetUserVariable(0, "user_supercharge_useammo", (GetUserVariable(0, "user_supercharge_useammo")+1) & 1);
		SetResultValue(GetUserVariable(0, "user_supercharge_useammo"));

		if(GetCVar("sh_debug_weapons"))
			log(s:"DEBUG: user_supercharge_useammo ", d:GetUserVariable(0, "user_supercharge_useammo"));
	}
	else
		SetResultValue(1);
}

// ------------
// MannCo Boxes
// ------------
#define GOOD 0
#define BAD 1

#define DELAY_NONE 0
#define DELAY_LONG 1
#define DELAY_SHORT 2
#define DELAY_BLUEIMP 3
#define DELAY_LAUGH 4
#define DELAY_BOSSLAUGH 5

struct BoxDelay_t
{
	str state;
	int time;
};

BoxDelay_t boxDelay[] =
{
	{ "None", 0 },
	{ "DelayLong", 791 },
	{ "DelayShort", 35 },
	{ "DelayImBlue", 742 },
	{ "DelayLaugh", 214 },
	{ "DelayBossLaugh", 235 },
};

struct MannCoBoxData_t
{
	str name;
	str state;
	int weight;
	int delaytype;
};

int tier1_totalweight[2];
int tier1_numentries[2];
MannCoBoxData_t tier1_good[] =
{
	{ "A Medical Bag.",					"MedBag",		75,		DELAY_NONE },
	{ "A Medkit.",						"Medkit",		40,		DELAY_NONE },
	{ "A Berserk Pack.",				"BerserkPack",	30,		DELAY_NONE },
	{ "A Tier 2 Weapon.",				"T2Weapon",		30,		DELAY_NONE },
	{ "A Tier 3 Weapon.",				"T3Weapon",		25,		DELAY_NONE },
	{ "A Tier 4 Weapon.",				"T4Weapon",		20,		DELAY_NONE },
	{ "A Tier 5 Weapon.",				"T5Weapon",		10,		DELAY_NONE },
	{ "A Rocket Launcher-Tier Weapon.",	"SuperShotgun",	25,		DELAY_NONE },
	{ "A Tier 1 Weapon Upgrade!",		"T1Upgrade",	25,		DELAY_NONE },
	{ "A Tier 2 Weapon Upgrade!",		"T2Upgrade",	20,		DELAY_NONE },
	{ "A Tier 3 Weapon Upgrade!",		"T3Upgrade",	15,		DELAY_NONE },
	{ "A Tier 4 Weapon Upgrade!",		"T4Upgrade",	10,		DELAY_NONE },
};

MannCoBoxData_t tier1_bad[] =
{
	{ "A Suicide Bomber.",					"SuicideBomber",	25,	DELAY_NONE },
	{ "A Chaingunner.",						"Chaingunner",		50,	DELAY_NONE },
	{ "A Pinky Demon.",						"Demon",			50,	DELAY_NONE },
	{ "You get nothing!",					"YouLose",			75,	DELAY_NONE },
	{ "Nothing. Fuck you. KTHXBYE.",		"FuckYou",			75,	DELAY_NONE },
	{ "The screams of an angry soldier.",	"WAAAAAAH",			75,	DELAY_NONE },
	{ "Absolutely nothing!",				"DED",				75,	DELAY_NONE },
	{ "A Lone Kago.",						"OneKago",			25,	DELAY_NONE },
	{ "A BFG Surprise!",					"BFGTrap",			15,	DELAY_NONE },
};

int tier2_totalweight[2];
int tier2_numentries[2];
MannCoBoxData_t tier2_good[] =
{
	{ "A Medical Bag.",					"MedBag",			75,	DELAY_NONE },
	{ "A Berserk Pack.",				"BerserkPack",		75,	DELAY_NONE },
	{ "An Ammo Belt!",					"AmmoBelt",			75,	DELAY_NONE },
	{ "A Deployable Shield.",			"Shield",			45,	DELAY_NONE },
	{ "A Mini-Sentry Box.",				"SENTREH",			45,	DELAY_NONE },
	{ "A Dispenser!",					"DISPENSER",		45,	DELAY_NONE },
	{ "An Ammo Expansion!",				"AmmoExpansion",	15,	DELAY_NONE },
	{ "A Tier 5 Weapon!",				"T6Weapon",			15,	DELAY_NONE },
	{ "A Tier 6 Weapon!",				"T6Weapon",			10,	DELAY_NONE },
	{ "A Tier 7 Weapon!",				"T7Weapon",			5,	DELAY_NONE },
	{ "A Gaster Blaster!",				"Gaster",			5,	DELAY_NONE },
};

MannCoBoxData_t tier2_bad[] =
{
	{ "A Suicide Bomber.",					"SuicideBomber",	25,	DELAY_NONE },
	{ "A swarm of lost souls!",				"LostSouls",		25,	DELAY_NONE },
	{ "You get nothing!",					"YouLose",			75,	DELAY_NONE },
	{ "Nothing. Fuck you. KTHXBYE.",		"FuckYou",			75,	DELAY_NONE },
	{ "The screams of an angry soldier.",	"WAAAAAAH",			75,	DELAY_NONE },
	{ "Absolutely nothing!",				"DED",				75,	DELAY_NONE },
	{ "The White Rabbit of Caerbannog!",	"WhiteRabbit",		5,	DELAY_NONE },
};

int tier3_totalweight[2];
int tier3_numentries[2];
MannCoBoxData_t tier3_good[] =
{
	{ "A Medical Bag.",					"MedBag",			75,	DELAY_NONE },
	{ "An Ammo Expansion!",				"AmmoExpansion",	50,	DELAY_NONE },
	{ "A Kan-Kan Powerup!",				"KanKan",			25,	DELAY_NONE },
	{ "A Soulsphere!",					"SoulSphere",		64,	DELAY_NONE },
	{ "An Invulnerability Powerup!",	"Invuln",			35,	DELAY_NONE },
	{ "An Energy Tank!", 				"ETank",			25,	DELAY_NONE },
	{ "A Tier 1 Weapon Upgrade!",		"T1Upgrade",		40,	DELAY_NONE },
	{ "A Tier 2 Weapon Upgrade!",		"T2Upgrade",		35,	DELAY_NONE },
	{ "A Tier 3 Weapon Upgrade!",		"T3Upgrade",		30,	DELAY_NONE },
	{ "A Tier 4 Weapon Upgrade!",		"T4Upgrade",		25,	DELAY_NONE },
	{ "A Tier 5 Weapon Upgrade!",		"T5Upgrade",		20,	DELAY_NONE },
	{ "A Tier 6 Weapon Upgrade!",		"T6Upgrade",		18,	DELAY_NONE },
	{ "A Tier 7 Weapon Upgrade!",		"T7Upgrade",		15,	DELAY_NONE },
	{ "An Extra Life!",					"ExtraLife",		30,	DELAY_NONE },
	{ "A Gaster Blaster!",				"Gaster",			25,	DELAY_NONE },
	{ "An Item Bundle!",				"Bundle",			25,	DELAY_NONE },
};

MannCoBoxData_t tier3_bad[] =
{
	{ "A Suicide Bomber.",					"SuicideBomber",	25,	DELAY_NONE },
	{ "The White Rabbit of Caerbannog!",	"WhiteRabbit",		25,	DELAY_NONE },
	{ "A Lone Kago.",						"OneKago",			30,	DELAY_NONE },
	{ "You get nothing!",					"YouLose",			50,	DELAY_NONE },
	{ "Absolutely nothing!",				"DED",				50,	DELAY_NONE },
	{ "Nothing. Fuck you. KTHXBYE.",		"FuckYou",			50,	DELAY_NONE },
	{ "The screams of an angry soldier.",	"WAAAAAAH",			50,	DELAY_NONE },
	{ "A BFG Surprise!",					"BFGTrap",			30,	DELAY_NONE },
	{ "A Bombing Run!",						"BombingRun",		25,	DELAY_LAUGH },
	{ "A Kago Hive!",						"KagoHive",			10,	DELAY_NONE },
};

int tier4_totalweight[2];
int tier4_numentries[2];
MannCoBoxData_t tier4_good[] =
{
	{ "All The Weapon Upgrades!",	"AllUpgrades",			8,		DELAY_BLUEIMP },
	{ "Legendary Armor!",			"WINRAR",				10,		DELAY_NONE },
	{ "An Extra Life!",				"ExtraLife",			30,		DELAY_NONE },
	{ "A Megasphere!",				"MegaSphere",			50,		DELAY_NONE },
	{ "Drugs?!",					"Joy",					50,		DELAY_NONE },
	{ "A Spew of Health Potions!",	"HealthVomit",			80,		DELAY_NONE },
	{ "An Upchuck of Orbs!",		"OrbVomit",				80,		DELAY_NONE },
	{ "A Barf of Bullets!",			"ClipVomit",			75,		DELAY_NONE },
	{ "A Regurgitation of Shells!",	"ShellVomit",			70,		DELAY_NONE },
	{ "A Cascade of Cells!",		"CellVomit",			65,		DELAY_NONE },
	{ "A Tier 5 Weapon Upgrade!",	"T5Upgrade",			30,		DELAY_NONE },
	{ "A Tier 6 Weapon Upgrade!",	"T6Upgrade",			25,		DELAY_NONE },
	{ "A Tier 7 Weapon Upgrade!",	"T7Upgrade",			20,		DELAY_NONE },
};

MannCoBoxData_t tier4_bad[] =
{
	{ "The Big Succ!",					"BIGSUCC",			20,		DELAY_NONE },
	{ "A Box of Farts N' Failure!",		"MANNFAIL",			100,	DELAY_NONE },
	{ "Allahu Akbar.",					"SNAKBAR",			10,		DELAY_NONE },
	{ "Grenade Vomit!",					"NadeVomit",		30,		DELAY_NONE },
	{ "Acid Puke!",						"BaronBallVomit",	100,	DELAY_NONE },
	{ "Bee Barf!",						"BeeVomit",			50,		DELAY_NONE },
	{ "A Bruiser Demon!",				"BruiserDemon",		45,		DELAY_LONG },
	{ "A Bunch of Rocket Imps!",		"RocketImps",		30,		DELAY_LONG },
	{ "A Horde of Annoying Zombies.",	"MiniZombieHorde",	25,		DELAY_SHORT },
};

int tier5_totalweight[2];
int tier5_numentries[2];
MannCoBoxData_t tier5_good[] =
{
	{ "A Medical Bag. \cgFuck you.",			"MedBag",			1,		DELAY_NONE },
	{ "A Kan-Kan Powerup!",						"KanKan",			10,		DELAY_NONE },
	{ "An Invulnerability Powerup!",			"Invuln",			5,		DELAY_NONE },
	{ "An Energy Tank!", 						"ETank",			4,		DELAY_NONE },
	{ "Legendary Armor!",						"WINRAR",			2,		DELAY_NONE },
	{ "A Megasphere... \cgAnd an archvile!",	"MegaSphereArchie",	75,		DELAY_NONE },
	{ "A Barf Bonanza!",						"VomitAll",			50,		DELAY_NONE },
};

MannCoBoxData_t tier5_bad[] =
{
	{ "Bruiser Brothers!",				"BruiserBros",		50,		DELAY_NONE },
	{ "Corrupt Fiend!",					"CorruptFiend",		50,		DELAY_NONE },
	{ "Corrupt Gosimer!",				"CorruptGosimer",	50,		DELAY_NONE },
	{ "Corrupt Kunai!",					"CorruptKunai",		50,		DELAY_NONE },
	{ "Corrupt Trio!",					"CorruptTrio",		50,		DELAY_BOSSLAUGH },
	{ "Deja Vu!",						"DejaVu",			50,		DELAY_NONE },
	{ "Kart Racists!",					"Kartrape",			50,		DELAY_NONE },
	{ "A Flood of Annoying Zombies!",	"BigZombieHorde",	15,		DELAY_BOSSLAUGH },
	{ "A Warlord Imp Army!",			"ImpWarlordHorde",	15,		DELAY_BOSSLAUGH },
	{ "A Horde of Ettins!",				"EttinHordeSpawn",	15,		DELAY_BOSSLAUGH },
};

script "TALLY_WEIGHTS" OPEN
{
	int i;

	// Tier 1
	// ------
	tier1_numentries[GOOD] = sizeof(tier1_good) / sizeof(tier1_good[0]);
	for(i = 0; i < tier1_numentries[GOOD]; i++)
		tier1_totalweight[GOOD] += tier1_good[i].weight;

	tier1_numentries[BAD] = sizeof(tier1_bad) / sizeof(tier1_bad[0]);
	for(i = 0; i < tier1_numentries[BAD]; i++)
		tier1_totalweight[BAD] += tier1_bad[i].weight;
	// ------

	// Tier 2
	// ------
	tier2_numentries[GOOD] = sizeof(tier2_good) / sizeof(tier2_good[0]);
	for(i = 0; i < tier2_numentries[GOOD]; i++)
		tier2_totalweight[GOOD] += tier2_good[i].weight;

	tier2_numentries[BAD] = sizeof(tier2_bad) / sizeof(tier2_bad[0]);
	for(i = 0; i < tier2_numentries[BAD]; i++)
		tier2_totalweight[BAD] += tier2_bad[i].weight;
	// ------

	// Tier 3
	// ------
	tier3_numentries[GOOD] = sizeof(tier3_good) / sizeof(tier3_good[0]);
	for(i = 0; i < tier3_numentries[GOOD]; i++)
		tier3_totalweight[GOOD] += tier3_good[i].weight;

	tier3_numentries[BAD] = sizeof(tier3_bad) / sizeof(tier3_bad[0]);
	for(i = 0; i < tier3_numentries[BAD]; i++)
		tier3_totalweight[BAD] += tier3_bad[i].weight;
	// ------

	// Tier 4
	// ------
	tier4_numentries[GOOD] = sizeof(tier4_good) / sizeof(tier4_good[0]);
	for(i = 0; i < tier4_numentries[GOOD]; i++)
		tier4_totalweight[GOOD] += tier4_good[i].weight;

	tier4_numentries[BAD] = sizeof(tier4_bad) / sizeof(tier4_bad[0]);
	for(i = 0; i < tier4_numentries[BAD]; i++)
		tier4_totalweight[BAD] += tier4_bad[i].weight;
	// ------

	// Tier 5
	// ------
	tier5_numentries[GOOD] = sizeof(tier5_good) / sizeof(tier5_good[0]);
	for(i = 0; i < tier5_numentries[GOOD]; i++)
		tier5_totalweight[GOOD] += tier5_good[i].weight;

	tier5_numentries[BAD] = sizeof(tier5_bad) / sizeof(tier5_bad[0]);
	for(i = 0; i < tier5_numentries[BAD]; i++)
		tier5_totalweight[BAD] += tier5_bad[i].weight;
	// ------

	if(GetCVar("sh_debug_boxes"))
	{
		log(s:"MannCo Box Info");
		log(s:"Tier 1 (GOOD): ", d:tier1_numentries[GOOD], s:" with total weight of ", d:tier1_totalweight[GOOD], s:".");
		log(s:"Tier 1 (BAD): ", d:tier1_numentries[BAD], s:" with total weight of ", d:tier1_totalweight[BAD], s:".");

		log(s:"Tier 2 (GOOD): ", d:tier2_numentries[GOOD], s:" with total weight of ", d:tier2_totalweight[GOOD], s:".");
		log(s:"Tier 2 (BAD): ", d:tier2_numentries[BAD], s:" with total weight of ", d:tier2_totalweight[BAD], s:".");

		log(s:"Tier 3 (GOOD): ", d:tier3_numentries[GOOD], s:" with total weight of ", d:tier3_totalweight[GOOD], s:".");
		log(s:"Tier 3 (BAD): ", d:tier3_numentries[BAD], s:" with total weight of ", d:tier3_totalweight[BAD], s:".");

		log(s:"Tier 4 (GOOD): ", d:tier4_numentries[GOOD], s:" with total weight of ", d:tier4_totalweight[GOOD], s:".");
		log(s:"Tier 4 (BAD): ", d:tier4_numentries[BAD], s:" with total weight of ", d:tier4_totalweight[BAD], s:".");

		log(s:"Tier 5 (GOOD): ", d:tier5_numentries[GOOD], s:" with total weight of ", d:tier5_totalweight[GOOD], s:".");
		log(s:"Tier 5 (BAD): ", d:tier5_numentries[BAD], s:" with total weight of ", d:tier5_totalweight[BAD], s:".");
	}
}

script "MANNCO_PICK" (int tier)
{
	int type = random(GOOD, BAD);
	int rnd, weight, delaytype, i;

	str pickedName;
	str pickedState;

	switch(tier)
	{
		case 0:
		case 1:
		{
			rnd = random(0, tier1_totalweight[type]-1);
			for(i=0; i < tier1_numentries[type]; i++)
			{
				weight = (!type) ? tier1_good[i].weight : tier1_bad[i].weight;
				if(rnd < weight)
				{
					delaytype = (!type) ? tier1_good[i].delaytype : tier1_bad[i].delaytype;
					pickedName = (!type) ? tier1_good[i].name : tier1_bad[i].name;
					pickedState = (!type) ? tier1_good[i].state : tier1_bad[i].state;
					break;
				}

				rnd -= weight;
			}
			break;
		}

		case 2:
		{
			rnd = random(0, tier2_totalweight[type]-1);
			for(i=0; i < tier2_numentries[type]; i++)
			{
				weight = (!type) ? tier2_good[i].weight : tier2_bad[i].weight;
				if(rnd < weight)
				{
					delaytype = (!type) ? tier2_good[i].delaytype : tier2_bad[i].delaytype;
					pickedName = (!type) ? tier2_good[i].name : tier2_bad[i].name;
					pickedState = (!type) ? tier2_good[i].state : tier2_bad[i].state;
					break;
				}

				rnd -= weight;
			}
			break;
		}

		case 3:
		{
			rnd = random(0, tier3_totalweight[type]-1);
			for(i=0; i < tier3_numentries[type]; i++)
			{
				weight = (!type) ? tier3_good[i].weight : tier3_bad[i].weight;
				if(rnd < weight)
				{
					delaytype = (!type) ? tier3_good[i].delaytype : tier3_bad[i].delaytype;
					pickedName = (!type) ? tier3_good[i].name : tier3_bad[i].name;
					pickedState = (!type) ? tier3_good[i].state : tier3_bad[i].state;
					break;
				}

				rnd -= weight;
			}
			break;
		}

		case 4:
		{
			rnd = random(0, tier4_totalweight[type]-1);
			for(i=0; i < tier4_numentries[type]; i++)
			{
				weight = (!type) ? tier4_good[i].weight : tier4_bad[i].weight;
				if(rnd < weight)
				{
					delaytype = (!type) ? tier4_good[i].delaytype : tier4_bad[i].delaytype;
					pickedName = (!type) ? tier4_good[i].name : tier4_bad[i].name;
					pickedState = (!type) ? tier4_good[i].state : tier4_bad[i].state;
					break;
				}

				rnd -= weight;
			}
			break;
		}

		case 5:
		{
			rnd = random(0, tier5_totalweight[type]-1);
			for(i=0; i < tier5_numentries[type]; i++)
			{
				weight = (!type) ? tier5_good[i].weight : tier5_bad[i].weight;
				if(rnd < weight)
				{
					delaytype = (!type) ? tier5_good[i].delaytype : tier5_bad[i].delaytype;
					pickedName = (!type) ? tier5_good[i].name : tier5_bad[i].name;
					pickedState = (!type) ? tier5_good[i].state : tier5_bad[i].state;
					break;
				}

				rnd -= weight;
			}
			break;
		}
	}

	if(delaytype != 0)
	{
		SetActorState(0, boxDelay[delaytype].state, false);
		Delay(boxDelay[delaytype].time);
	}

	SetHudSize(640, 480, true);
	HudMessageBold(s:pickedName;
	HUDMSG_TYPEON | HUDMSG_LOG, 70, (!type) ? CR_GREEN : CR_RED, 320.4, 144.1, 5.0, 0.01, 0.5);
	SetActorState(0, pickedState, false);
}