#Library "SH_StrikersCode"
#include "zcommon.acs"
#import "SH_GlobalData.acsx"

// All code in this file is by StrikerTheHedgefox.
// Please ask permission if you want to use this!

#define ONE_16 (1<<16)

function int seek_string(str string, str substring, int startPos)
{
	int stringLength = StrLen(string);
	int substringLength = StrLen(substring);
	int firstMatchPos = -1;
	int i,j;

	if(startPos < 0)
		return -1;

	for(i = startPos; i < stringLength; i++)
	{
		if(GetChar(string, i) != GetChar(substring, 0))
			continue;

		firstMatchPos = i;
		for(j = 0; j < substringLength; j++)
		{
			int char1 = GetChar(string, i+j);
			int char2 = GetChar(substring, j);
			if(char1 != char2)
				break;
		}

		if(j < substringLength)
			continue;

		return firstMatchPos;
	}

	return -1;
}

enum
{
	WADCOMPAT_UNINITIALIZED = 0,
	WADCOMPAT_NORMAL,
	WADCOMPAT_MAYHEM18O,
	WADCOMPAT_MAYHEM18P,
	WADCOMPAT_MAYHEM19,
	WADCOMPAT_STRANGEAEONS,
	WADCOMPAT_BTSXE2,
};

function void detect_wads(void)
{
	if(IsNetworkGame() && (ConsolePlayerNumber() != -1)) // Hack to prevent Zandronum from executing this on a client
		return;

	// We only need to do this once, the first time any map is loaded.
	if(GetCVar("sh_compat_mode") != WADCOMPAT_UNINITIALIZED)
		return;

	int startIndex;
	str mapinfo_data;

	while(true)
	{
		startIndex = LumpOpen("MAPINFO", startIndex + 1);
		if (startIndex == -1)
		{
			Log(s:"No more MAPINFO lumps found.");
			break;
		}
		Log(s:"Next MAPINFO lump was found at index ", d:startIndex, s:".");

		int size = LumpGetInfo(startIndex, LUMP_INFO_SIZE);
		int find_pos = 0;
		mapinfo_data = LumpReadString(startIndex, 0, size);

		find_pos = seek_string(mapinfo_data, "map map01 \"Sundowning\"", 0);
		find_pos = seek_string(mapinfo_data, "map map02 \"Asterion\"", find_pos);
		if(find_pos != -1)
		{
			Log(s:"MAYhem 2018: Orange Edition Detected");
			SetCVar("sh_compat_mode", WADCOMPAT_MAYHEM18O);
			return;
		}
		

		find_pos = seek_string(mapinfo_data, "map map01 \"Failed Mining Operation\"", 0);
		find_pos = seek_string(mapinfo_data, "map map02 \"Vasiliki Thalassa\"", find_pos);
		if(find_pos != -1)
		{
			Log(s:"MAYhem 2018: Purple Edition Detected");
			SetCVar("sh_compat_mode", WADCOMPAT_MAYHEM18P);
			return;
		}
		
		find_pos = seek_string(mapinfo_data, "map map01 \"Spiteful Hall\"", 0);
		find_pos = seek_string(mapinfo_data, "map map02 \"Murskville\"", find_pos);
		if(find_pos != -1)
		{
			Log(s:"MAYhem 2019: Blood for the Doom God Detected");
			SetCVar("sh_compat_mode", WADCOMPAT_MAYHEM19);
			return;
		}

		find_pos = seek_string(mapinfo_data, "map E1M1 \"The Traveler\"", 0);
		find_pos = seek_string(mapinfo_data, "map E1M2 \"Resident Evil\"", find_pos);
		if(find_pos != -1)
		{
			Log(s:"Strange Aeons Detected");
			SetCVar("sh_compat_mode", WADCOMPAT_STRANGEAEONS);
			return;
		}

		find_pos = seek_string(mapinfo_data, "map MAP01 \"Shadow Port\"", 0);
		find_pos = seek_string(mapinfo_data, "map MAP02 \"Underwater Explosions\"", find_pos);
		if(find_pos != -1)
		{
			Log(s:"Back To Saturn X: Episode 2 Detected");
			SetCVar("sh_compat_mode", WADCOMPAT_BTSXE2);
			return;
		}

		// Make sure to close the lump again to free the handle.
		LumpClose(startIndex);
	}

	SetCVar("sh_compat_mode", WADCOMPAT_NORMAL);
}

script "WAD_COMPAT_TEXTURE_SWAPS" OPEN
{
	switch (GetCVar("sh_compat_mode"))
	{
		case WADCOMPAT_BTSXE2:
		{
			ReplaceTextures("DBRAIN1", "LFALL2");
			break;
		}
	}
}

// Kill script, for things like orbs, lives, and box drops.
script "ON_KILL" KILL
{
	if(!CheckFlag(0, "ISMONSTER")) // Not monster? Don't bother.
		terminate;

	SetHudSize(640, 480, true);

	int i;

	// Get some properties of our monster.
	str Class = GetActorClass(0);
	int Health = GetActorProperty(0, APROP_SpawnHealth);
	int Height = GetActorProperty(0, APROP_Height);
	int Damage = GetActorProperty(0, APROP_Damage);

	// Base velocities for Orbs
	int HOrbSpeed = max(GetActorProperty(0, APROP_Radius) / 4, 6.0);
	int VOrbSpeed = max(Height/6, 6.0);

	int NumOrbs = 0;

	if(GetCVar("sh_orbs_logarithmic"))
	{
		// Base Multiplier * Health / (Health + Speed of Deminishing Return)
		NumOrbs = 50 * Health / (Health + 1500); // Calculate number of Orbs.
	}
	else
	{
		NumOrbs = Health/40;
	}

	// Certain flags add a bonus.
	if(CheckFlag(0, "MISSILEMORE"))			NumOrbs += 1;
	if(CheckFlag(0, "MISSILEEVENMORE"))		NumOrbs += 1;
	if(CheckFlag(0, "SPECTRAL"))			NumOrbs += 1;
	if(CheckFlag(0, "DONTRIP"))				NumOrbs += 1;
	if(CheckFlag(0, "NOICEDEATH"))			NumOrbs += 1;
	if(CheckFlag(0, "STEALTH"))				NumOrbs += 2;
	if(CheckFlag(0, "ALWAYSFAST"))			NumOrbs += 2;
	if(CheckFlag(0, "NORADIUSDMG"))			NumOrbs += 2;
	if(CheckFlag(0, "BOSS"))				NumOrbs += 10; // Bosses get more orbs.

	if(Damage >= 250) // Super high damage enemies (like the white rabbit) double orbs.
		NumOrbs *= 2;

	if(NumOrbs <= 0) // Everything is worth at least one orb.
		NumOrbs = 1;

	for(i = 0; i < NumOrbs; i++)
	{
		int TID = UniqueTID (0, 0);
		SpawnForced("DEMONENERGY", GetActorX(0), GetActorY(0), GetActorZ(0)+(Height/2), TID, random(0, 255));
		SetActorVelocity(TID, random(-HOrbSpeed, HOrbSpeed), random(-HOrbSpeed, HOrbSpeed), random(2.0, VOrbSpeed), false, false);
		Thing_ChangeTID(TID, 0);
	}

	// Extra Life Drops
	// ----------------
	if(GetUserVariable(0, "user_extralife_chance") != -1) // -1 = No spawn
	{
		bool doLifeSpawn = false;
		int lifeRandom = Random(1, 200);
		if(GetUserVariable(0, "user_extralife_chance") > 0)
		{
			if(lifeRandom <= GetUserVariable(0, "user_extralife_chance"))
				doLifeSpawn = true;
		}
		else
		{
			if(Health >= 6000) // 100%
				doLifeSpawn = true;
			else if(Health >= 5000 && lifeRandom <= 150) // 75%
				doLifeSpawn = true;
			else if(Health >= 4000 && lifeRandom <= 100) // 50%
				doLifeSpawn = true;
			else if(Health >= 3000 && lifeRandom <= 80) // 40%
				doLifeSpawn = true;
			else if(Health >= 2500 && lifeRandom <= 20) // 10%
				doLifeSpawn = true;
			else if(Health >= 1000 && lifeRandom <= 2) // 1%
				doLifeSpawn = true;
			else if(Health >= 500 && lifeRandom <= 1) // 0.5%
				doLifeSpawn = true;
		}

		if(doLifeSpawn)
		{
			int lifeTID = UniqueTID (0, 0);
			SpawnForced("extralifethingy", GetActorX(0), GetActorY(0), GetActorZ(0)+(Height/2), lifeTID, random(0, 255));
			SetActorVelocity(lifeTID, random(-HOrbSpeed/2, HOrbSpeed/2), random(-HOrbSpeed/2, HOrbSpeed/2), random(2.0, VOrbSpeed), false, false);

			if(Health >= 8000) // Spawn another if health pool is massive.
			{
				lifeTID = UniqueTID (0, 0);
				SpawnForced("extralifethingy", GetActorX(0), GetActorY(0), GetActorZ(0)+(Height/2), lifeTID, random(0, 255));
				SetActorVelocity(lifeTID, random(-HOrbSpeed/2, HOrbSpeed/2), random(-HOrbSpeed/2, HOrbSpeed/2), random(2.0, VOrbSpeed), false, false);

				HudMessageBold(s:"Two extra lives were dropped by ", s:(startsWithVowel(StrParam(n:0))) ? "an " : "a ", n:0;
				HUDMSG_TYPEON | HUDMSG_LOG, 69, CR_CYAN, 320.0, 120.0, 5.0, 0.01, 0.5);
			}
			else
			{
				HudMessageBold(s:"An extra life was dropped by ", s:(startsWithVowel(StrParam(n:0))) ? "an " : "a ", n:0;
				HUDMSG_TYPEON | HUDMSG_LOG, 69, CR_CYAN, 320.0, 120.0, 5.0, 0.01, 0.5);
			}
		}
	}

	// ManCo Box Drops
	// ---------------
	if(GetUserVariable(0, "user_manncobox_chance") != -1)
	{
		bool doBoxSpawn = false;
		int boxRandom = Random(1, 400);
		int boxChance = Health/40;

		if(CheckFlag(0, "BOSS") || CheckFlag(0, "BOSSDEATH"))
			boxChance += 10;

		if (boxChance > 400)
			boxChance = 400;
		else if (boxChance < 1)
			boxChance = 1;

		if(GetUserVariable(0, "user_manncobox_chance") > 0)
		{
			if(boxRandom <= GetUserVariable(0, "user_manncobox_chance"))
				doBoxSpawn = true;
		}
		else if(boxRandom <= boxChance && Health > 15)
			doBoxSpawn = true;

		if(doBoxSpawn)
		{
			int tierWeights[5] = { 1, 2, 4, 6, 8 };
			int maxTier = 1;
			int totalWeight = 0;

			if(Health >= 500) // Tier 2
				maxTier++;
			if(Health >= 1000) // Tier 3
				maxTier++;
			if(Health >= 2500) // Tier 4
				maxTier++;
			if(Health >= 4000) // Tier 5
				maxTier++;

			if(Health < 2500 && (CheckFlag(0, "BOSS") || CheckFlag(0, "BOSSDEATH"))) // If low health enemy is boss, boost.
				maxTier++;

			if(maxTier > 5)
				maxTier = 5;

			// This should make the weight exponentially higher for every 4000 health over 4000.
			for(i = 0; i < maxTier; i++)
			{
				int scale = FixedDiv(Health << 16, 4000.0);
				int newWeight = FixedMul((tierWeights[i]*tierWeights[i]) << 16, scale) >> 16;
				if(newWeight < 1)
					newWeight = 1;
				tierWeights[i] = newWeight;
				totalWeight += newWeight;
			}

			if(GetCVar("sh_debug_boxes"))
				log(s:"DEBUG: Tier weights - ", d:tierWeights[0], s:", ", d:tierWeights[1], s:", ", d:tierWeights[2], s:", ", d:tierWeights[3], s:", ", d:tierWeights[4]);

			int rnd = random(0, totalWeight-1);
			for(i=0; i < maxTier; i++)
			{
				int weight = tierWeights[i];
				if(rnd < weight)
				{
					int boxTID = UniqueTID (0, 0);
					SpawnForced("ActiveBox1", GetActorX(0), GetActorY(0), GetActorZ(0)+(Height/2), boxTID, random(0, 255));
					SetUserVariable(boxTID, "user_tier", i+1);

					HudMessageBold(s:"A tier ", d:i+1, s:" MannCo box was dropped by ", s:(startsWithVowel(StrParam(n:0))) ? "an " : "a ", n:0, s:"!\n\cjWhat will you get?!";
					HUDMSG_TYPEON | HUDMSG_LOG, 70, CR_GOLD, 320.4, 128.1, 30.0, 0.01, 0.5);
					break;
				}
				rnd -= weight;
			}
		}
	}

	SetActivatorToTarget(0); // Set activator to the one who killed this monster.

	if(GetCVar("sh_debug_orbs"))
		log(s:"DEBUG: ", n:0, s:" killed ", s:Class, s:" [", d:Health, s:"] ", s:"Orbs: ", d:NumOrbs);
}

// Damage Numbers
// --------------
// This is code ported over from SMMP, another one of my projects.
function int pow (int x, int n)
{
	int y = 1;
	while (n-- > 0) y *= x;
	return y;
}

function int GetDigit(int Num, int Digit)
{
	return (Num / pow(10, Digit)) % 10 ;
}

function void PrintDamage(int damage)
{
	if(damage > 9999)
		damage = 9999;

	int Digit1 = GetDigit(damage, 0);
	int Digit2 = GetDigit(damage, 1);
	int Digit3 = GetDigit(damage, 2);
	int Digit4 = GetDigit(damage, 3);

	int height = GetActorProperty(0, APROP_Height);
	if(GetActorProperty(0, APROP_Health) <= 0)
		height *= 4;

	int x = GetActorX(0) + Random(-10.0, 10.0);
	int y = GetActorY(0) + Random(-10.0, 10.0);
	int z = GetActorZ(0) + height + Random(-10.0, 5.0);

	int ceilingZ = GetActorCeilingZ(0);
	if(z+10.0 >= ceilingZ)
		z = (ceilingZ-10.0) + Random(-10.0, 0.0);

	int TranslationNumber = Random(6000, 6007);

	int NumberID = UniqueTID(6000, 500);
	
	switch(Digit1)
	{
		case 0: Spawn("Digit1Num0", x, y, z, NumberID, 0); break;
		case 1: Spawn("Digit1Num1", x, y, z, NumberID, 0); break;
		case 2: Spawn("Digit1Num2", x, y, z, NumberID, 0); break;
		case 3: Spawn("Digit1Num3", x, y, z, NumberID, 0); break;
		case 4: Spawn("Digit1Num4", x, y, z, NumberID, 0); break;
		case 5: Spawn("Digit1Num5", x, y, z, NumberID, 0); break;
		case 6: Spawn("Digit1Num6", x, y, z, NumberID, 0); break;
		case 7: Spawn("Digit1Num7", x, y, z, NumberID, 0); break;
		case 8: Spawn("Digit1Num8", x, y, z, NumberID, 0); break;
		case 9: Spawn("Digit1Num9", x, y, z, NumberID, 0); break;
	}

	if(damage >= 10)
	{
		switch(Digit2)
		{
			case 0: Spawn("Digit2Num0", x, y, z, NumberID, 0); break;
			case 1: Spawn("Digit2Num1", x, y, z, NumberID, 0); break;
			case 2: Spawn("Digit2Num2", x, y, z, NumberID, 0); break;
			case 3: Spawn("Digit2Num3", x, y, z, NumberID, 0); break;
			case 4: Spawn("Digit2Num4", x, y, z, NumberID, 0); break;
			case 5: Spawn("Digit2Num5", x, y, z, NumberID, 0); break;
			case 6: Spawn("Digit2Num6", x, y, z, NumberID, 0); break;
			case 7: Spawn("Digit2Num7", x, y, z, NumberID, 0); break;
			case 8: Spawn("Digit2Num8", x, y, z, NumberID, 0); break;
			case 9: Spawn("Digit2Num9", x, y, z, NumberID, 0); break;
		}
	}

	if(damage >= 100)
	{
		switch(Digit3)
		{
			case 0: Spawn("Digit3Num0", x, y, z, NumberID, 0); break;
			case 1: Spawn("Digit3Num1", x, y, z, NumberID, 0); break;
			case 2: Spawn("Digit3Num2", x, y, z, NumberID, 0); break;
			case 3: Spawn("Digit3Num3", x, y, z, NumberID, 0); break;
			case 4: Spawn("Digit3Num4", x, y, z, NumberID, 0); break;
			case 5: Spawn("Digit3Num5", x, y, z, NumberID, 0); break;
			case 6: Spawn("Digit3Num6", x, y, z, NumberID, 0); break;
			case 7: Spawn("Digit3Num7", x, y, z, NumberID, 0); break;
			case 8: Spawn("Digit3Num8", x, y, z, NumberID, 0); break;
			case 9: Spawn("Digit3Num9", x, y, z, NumberID, 0); break;
		}
	}

	if(damage >= 1000)
	{
		switch(Digit4)
		{
			case 0: Spawn("Digit4Num0", x, y, z, NumberID, 0); break;
			case 1: Spawn("Digit4Num1", x, y, z, NumberID, 0); break;
			case 2: Spawn("Digit4Num2", x, y, z, NumberID, 0); break;
			case 3: Spawn("Digit4Num3", x, y, z, NumberID, 0); break;
			case 4: Spawn("Digit4Num4", x, y, z, NumberID, 0); break;
			case 5: Spawn("Digit4Num5", x, y, z, NumberID, 0); break;
			case 6: Spawn("Digit4Num6", x, y, z, NumberID, 0); break;
			case 7: Spawn("Digit4Num7", x, y, z, NumberID, 0); break;
			case 8: Spawn("Digit4Num8", x, y, z, NumberID, 0); break;
			case 9: Spawn("Digit4Num9", x, y, z, NumberID, 0); break;
		}
	}

	Thing_SetTranslation(NumberID, TranslationNumber);
	SetActorVelocity(NumberID, 0, 0, 0.25, 0, 0);

	return;
}

script "GENERATE_DMG_TRANSLATIONS" OPEN
{
	CreateTranslation(6001, 160:160=[255, 0, 0]:[255, 0, 0]); // Red
	CreateTranslation(6002, 160:160=[0, 255, 0]:[0, 255, 0]); // Green
	CreateTranslation(6003, 160:160=[0, 0, 255]:[0, 0, 255]); // Blue
	CreateTranslation(6004, 160:160=[255, 255, 0]:[255, 255, 0]); // Yellow
	CreateTranslation(6005, 160:160=[0, 255, 255]:[0, 255, 255]); // Cyan
	CreateTranslation(6006, 160:160=[255, 0, 255]:[255, 0, 255]); // Magenta
	CreateTranslation(6007, 160:160=[255, 255, 255]:[255, 255, 255]); // White
}

#define HIT_OTHER 0
#define HIT_FLESH 1

function void hit_marker(int soundType, bool friendly)
{
	if(friendly)
		LocalAmbientSound("hitsound_friend", 64);
	else
	{
		switch(soundType)
		{
			case HIT_FLESH:
				LocalAmbientSound("hitsound_flesh", 64);
				break;
			default:
				LocalAmbientSound("hitsound_generic", 32);
				break;
		}
	}

	SetHudSize(1024, 768, 0);
	int id = 6969;
	if(!friendly)
		SetFont("HITMARK");
	else
	{
		id = 6970;
		SetFont("HITFREN");
	}
	HudMessage(s:"A";
	HUDMSG_FADEOUT, id, CR_UNTRANSLATED, 512.4, 384.0, 1, 0.5);

	return;
}

function bool checkEvenGround(int x, int y, int radius, int maxDiff)
{
	int centerFloorZ = GetSectorFloorZ(0, x >> 16, y >> 16);
	int diffs[8];
	
	diffs[0] = abs(centerFloorZ - GetSectorFloorZ(0, (x + radius) >> 16, (y) >> 16));
	diffs[1] = abs(centerFloorZ - GetSectorFloorZ(0, (x - radius) >> 16, (y) >> 16));
	
	diffs[2] = abs(centerFloorZ - GetSectorFloorZ(0, (x) >> 16, (y + radius) >> 16));
	diffs[3] = abs(centerFloorZ - GetSectorFloorZ(0, (x) >> 16, (y - radius) >> 16));
	
	diffs[4] = abs(centerFloorZ - GetSectorFloorZ(0, (x - radius) >> 16, (y - radius) >> 16));
	diffs[5] = abs(centerFloorZ - GetSectorFloorZ(0, (x + radius) >> 16, (y - radius) >> 16));
	
	diffs[6] = abs(centerFloorZ - GetSectorFloorZ(0, (x - radius) >> 16, (y + radius) >> 16));
	diffs[7] = abs(centerFloorZ - GetSectorFloorZ(0, (x + radius) >> 16, (y + radius) >> 16));
	
	for(int i = 0; i < 8; i++)
	{
		if(diffs[i] > maxDiff)
			return false;
	}
	
	return true;
}

function void multiply_actor(int mult)
{
	if(IsNetworkGame() && (ConsolePlayerNumber() != -1)) // Hack to prevent Zandronum from executing this on a client
		return;

	vec3_t pos = { GetActorX(0), GetActorY(0), GetActorZ(0) };
	int floorZ = GetSectorFloorZ(0, pos.x >> 16, pos.y >> 16);
	int radius = GetActorProperty(0, APROP_Radius);
	int angle = GetActorAngle(0)>>8;
	
	bool ambush = CheckFlag(0, "AMBUSH");
	bool friendly = CheckFlag(0, "FRIENDLY");
	bool stealth = CheckFlag(0, "STEALTH");
	bool standstill = CheckFlag(0, "STANDSTILL");
	bool dormant = CheckFlag(0, "DORMANT");

	int thisTID = ActivatorTID();
	int enemyCount = 1;
	int dir = 0;
	int stride = 1;
	int stride_cycle = 0;
	int spawnAttempts = 0;

	if(GetCVar("sh_debug_spawns"))
		log(s:"Multiplying ", s:GetActorClass(0), s:" (Ambush: ", d:ambush, s:")");

	do
	{
		int iter = 0;

		do
		{
			iter++;
			switch (dir)
			{
				case 0: pos.y += radius*2; break;
				case 1: pos.x += radius*2; break;
				case 2: pos.y -= radius*2; break;
				case 3: pos.x -= radius*2; break;
			}

			int newFloorZ = GetSectorFloorZ(0, pos.x >> 16, pos.y >> 16);
			int floorZDiff = abs(floorZ - newFloorZ);
			int beaconTID = UniqueTID(0);

			bool floorZPassed = (floorZDiff < 24.0);
			bool sightPassed = false;
			int spawnPassed = 0;
			
			if(!checkEvenGround(pos.x, pos.y, radius, 16.0))
				floorZPassed = 0;
				
			if(floorZPassed)
			{
				if(Spawn("SightCheckBeacon", pos.x, pos.y, newFloorZ, beaconTID, 0))
				{
					sightPassed = CheckSight(0, beaconTID, 0);
					if(sightPassed)
					{
						int uTID = UniqueTID(0);

						spawnPassed = Spawn(GetActorClass(0), pos.x, pos.y, newFloorZ, uTID, angle);

						if(spawnPassed)
						{
							SetActorProperty(uTID, APROP_Ambush, ambush); // ChangeActorFlag(uTID, "AMBUSH", ambush);
							SetActorProperty(uTID, APROP_Dormant, dormant); // ChangeActorFlag(uTID, "DORMANT", dormant);
							SetActorProperty(uTID, APROP_ReactionTime, random(8, 14));

							ChangeActorFlag(uTID, "FRIENDLY", friendly);
							ChangeActorFlag(uTID, "STEALTH", stealth);
							ChangeActorFlag(uTID, "STANDSTILL", standstill);
							ChangeActorFlag(uTID, "DROPPED", 0);

							Thing_ChangeTID(uTID, thisTID);
						}
					}
				}
			}

			if(!floorZPassed || !sightPassed || !spawnPassed)
			{
				spawnAttempts++;
				if(spawnAttempts >= 50)
				{
					if(GetCVar("sh_debug_spawns"))
						log(s:"Giving up after too many attempts to spawn.");

					enemyCount = mult;
					break;
				}

				continue;
			}

			spawnAttempts = 0;
			enemyCount++;

			if(GetCVar("sh_debug_spawns"))
				log(s:"count: ", d:enemyCount, s:" iter: ", d:iter, s:" stride: ", d:stride, s:" z: ", f:pos.z, s:" floorz: ", f:GetSectorFloorZ(0, pos.x>>16, pos.y>>16));
		} while((iter < stride) && enemyCount < mult);

		dir = (dir+1)%4;
		stride_cycle++;
		if((stride_cycle % 2) == 0)
			stride++;
	} while(enemyCount < mult);
}

function void actor_swap(str replace, str with, int chance)
{
	if(!CheckActorClass(0, replace))
		return;

	if((chance >= 255) || (random(0, 255) < chance))
	{
		int thisTID = ActivatorTID();
		int uTID = UniqueTID();
		int xvel = GetActorVelX(0);
		int yvel = GetActorVelY(0);
		int zvel = GetActorVelZ(0);
		bool dropped = CheckFlag(0, "DROPPED");
		bool ambush = CheckFlag(0, "AMBUSH");
		bool friendly = CheckFlag(0, "FRIENDLY");
		bool stealth = CheckFlag(0, "STEALTH");
		bool standstill = CheckFlag(0, "STANDSTILL");
		bool dormant = CheckFlag(0, "DORMANT");

		int success = SpawnForced(with, GetActorX(0), GetActorY(0), GetActorZ(0), uTID, GetActorAngle(0));
		if(success)
		{
			SetActorVelocity(uTID, xvel, yvel, zvel, false, false);

			SetActorProperty(uTID, APROP_Ambush, ambush); // ChangeActorFlag(uTID, "AMBUSH", ambush);
			SetActorProperty(uTID, APROP_Dormant, dormant); // ChangeActorFlag(uTID, "DORMANT", dormant);
			ChangeActorFlag(uTID, "DROPPED", dropped);
			ChangeActorFlag(uTID, "FRIENDLY", friendly);
			ChangeActorFlag(uTID, "STEALTH", stealth);
			ChangeActorFlag(uTID, "STANDSTILL", standstill);

			if(GetCVar("sh_debug_spawns"))
				log(s:replace, s:"(TID: ", d:thisTID, s:") has been swapped with ", s:with, s:" (Species: ", s:GetActorProperty(0, APROP_Species), s:")");

			// These must be last!
			// Stops RandomSpawners from doing anything.
			// NEVER REMOVE THIS, THE CONSEQUENCES ARE SEVERE IF YOU DO. (IE: Memory rape and potential system freeze and/or BSOD.)
			SetActorProperty(0, APROP_Species, "NullHax"); 
			Thing_Remove(0);

			SetActivator(uTID);
			Thing_ChangeTID(uTID, thisTID);
		}
	}

	return;
}

function void kunai_health_sap(int arg1, int victimHealth, int healDiv, int ptr)
{
	if(SetActivator(0, AAPTR_DAMAGE_SOURCE))
	{
		int oldTID = ActivatorTID();
		int srcUTID = UniqueTID();
		Thing_ChangeTID(0, srcUTID);
		SetActivator(0, ptr);

		int actualDmg = arg1;
		if(victimHealth < arg1)
			actualDmg = victimHealth;

		int numOrbs = clamp(actualDmg >> 4, 1, 10);
		int healAmt = max(max(actualDmg/healDiv, 1)/numOrbs, 1);
		for(int i = 0; i < numOrbs; i++)
		{
			int uTID = UniqueTID();
			SpawnProjectile(0, "HealingSeeker", random(0,255), random(0, 30), random(-128, 128), 0, uTID);
			SetActivator(uTID);
			SetPointer(AAPTR_TRACER, srcUTID);
			SetPointer(AAPTR_TARGET, srcUTID);
			SetUserVariable(uTID, "user_healamt", healAmt);
			SetActivator(0, ptr);
		}

		Thing_ChangeTID(srcUTID, oldTID);
	}
}

script "KUNAI_GIVE_HEALTH" (int type)
{
	if(IsNetworkGame() && (ConsolePlayerNumber() != -1)) // Hack to prevent Zandronum from executing this on a client
		terminate;

	int healAmt = GetUserVariable(0, "user_healamt");
	int type = GetUserVariable(0, "user_type");
	
	if(SetActivator(0, AAPTR_TARGET))
	{
		int curHealth = GetActorProperty(0, APROP_Health);
		int armorAmt = 0;
		
		if(curHealth >= 100)
		{
			armorAmt = healAmt;
			healAmt = 0;
		}
		else if(curHealth+healAmt >= 100)
		{
			int oldHealAmt = healAmt;
			healAmt = 100 - curHealth;
			armorAmt = oldHealAmt - healAmt;
		}
		
		if(healAmt > 0)
			SetActorProperty(0, APROP_Health, curHealth+healAmt);
		
		if(armorAmt > 0 && !CheckInventory("PowerShieldGate"))
			GiveInventory("KunaisArmorStealBonus", armorAmt);
	}
}

function int handle_damage_event(int type, int arg1, int arg2)
{
	// -------------
	int fixedDamage;	// Damage as a fixed-point value. Re-initialized and re-used in multiple places.
	int yeetAmt;		// Vertical push.
	// -------------

	int victimPlayerNum = PlayerNumber();
	int victimHealth = GetActorProperty(0, APROP_Health);
	bool victimIsMonster = CheckFlag(0, "ISMONSTER");
	bool victimCanBleed = !CheckFlag(0, "NOBLOOD");
	bool victimIsFriendly = (CheckFlag(0, "FRIENDLY") || (victimPlayerNum != -1));

	bool doTeamDamageScale = false;
	bool directMonsterDamage = false;
	bool wasConcussed = false;
	bool wasTelefrag = (!StrIcmp(arg2, "spawntelefrag") || !StrIcmp(arg2, "telefrag"));

	str inflictorClass = "Unknown";

	if(SetActivator(0, AAPTR_DAMAGE_INFLICTOR))
	{
		directMonsterDamage = CheckFlag(0, "ISMONSTER");
		inflictorClass = GetActorClass(0);

		// Damage Falloff Calc = fix16(basedamage) - (fix16(falloff) * tics/rate) >> 16
		int falloffAmt = GetUserVariable(0, "user_falloff");
		if(falloffAmt > 0) // Falloff calc for Max's blaster bolts.
		{
			int falloffRate = GetUserVariable(0, "user_falloffrate");
			if(falloffRate <= 0)
				falloffRate = 1;

			fixedDamage = arg1 << 16;
			int minDamage = GetUserVariable(0, "user_mindmg");
			int falloffTics = GetUserVariable(0, "user_fallofftics");

			arg1 = (fixedDamage - (falloffAmt * (falloffTics/falloffRate))) >> 16;

			if(arg1 < minDamage)
				arg1 = minDamage;
		}

		wasConcussed = CheckActorClass(0, "ConcussionBlast");
		if(CheckActorClass(0, "FistPuff") || wasConcussed)
		{
			int yeetForceBase = arg1;
			yeetAmt = random(yeetForceBase >> 2, yeetForceBase);
		}

		if(victimIsMonster && victimCanBleed)
		{
			if(	CheckActorClass(0, "Beem_Slash") ||
				CheckActorClass(0, "SoulreaperPuff") ||
				CheckActorClass(0, "SoulreaperPuff_SweetSpot"))
			{
				kunai_health_sap(arg1, victimHealth, 6, AAPTR_DAMAGE_INFLICTOR);
			}
			else if(CheckActorClass(0, "KunaisLifeStealingPuff"))
			{
				kunai_health_sap(arg1, victimHealth, 8, AAPTR_DAMAGE_INFLICTOR);
			}
		}

		if(GetCVar("sh_debug_damage"))
			log(s:"DEBUG: Entity damaged by ", s:GetActorClass(0));
	}

	if(SetActivator(0, AAPTR_DAMAGE_SOURCE))
	{
		int attackerPlayerNum = PlayerNumber();
		bool attackerIsMonster = CheckFlag(0, "ISMONSTER");
		bool attackerIsFriendly = (CheckFlag(0, "FRIENDLY") || (attackerPlayerNum != -1));

		if(attackerPlayerNum != -1) // Source is player
		{
			if(victimIsMonster || (victimIsFriendly && victimPlayerNum != attackerPlayerNum))
				hit_marker(victimCanBleed ? HIT_FLESH : HIT_OTHER, victimIsFriendly);

			// Gosimer's Berserk Buff
			if(CheckActorClass(0, "Gosimer") && CheckInventory("PowerStrength"))
				arg1 += 1;

			if(victimIsMonster && victimIsFriendly) // Player hitting friendly monster.
				doTeamDamageScale = true;
		}
		else if(attackerIsMonster) // Source is a monster.
		{
			if(attackerIsFriendly && victimPlayerNum != -1) // Friendly monster hitting player.
				doTeamDamageScale = true;
		}

		if(GetCVar("sh_friendly_scaledamage") && doTeamDamageScale && !wasTelefrag)
		{
			int teamDamage = GetCvar("teamdamage");
			fixedDamage = arg1 << 16;
			arg1 = FixedMul(fixedDamage, teamDamage) >> 16;
		}
	}

	if(SetActivator(0, AAPTR_DAMAGE_TARGET))
	{
		if(yeetAmt > 0 && !CheckFlag(0, "DONTBLAST"))
		{
			int assMass = GetActorProperty(0, APROP_Mass) >> 8;
			if(assMass <= 0)
				assMass = 1;

			if(assMass > 1)
			{
				yeetAmt /= assMass;
				if(yeetAmt <= 0)
					yeetAmt = 1; // We always do a little bit of yeeting.
			}

			if(!CheckFlag(0, "FLOAT"))
				ThrustThingZ(0, yeetAmt, 0, 1);

			if(wasConcussed && victimIsMonster)
				ChangeFlag("BLASTED", true);
		}

		if(wasConcussed)
			SpawnForced("ConcussionExtra", GetActorX(0), GetActorY(0), GetActorZ(0), 0, GetActorAngle(0));

		if(victimIsMonster && victimCanBleed)
		{
			if(!StrIcmp(inflictorClass, "GoldCryoShot"))
				kunai_health_sap(arg1, victimHealth, 8, AAPTR_DAMAGE_TARGET);
		}

		if(victimPlayerNum != -1)
		{
			// These inventory items provide invulnerability.
			if(
				CheckInventory("PowerInvulnerable") ||
				CheckInventory("PowerSpawnProtection") ||
				CheckInventory("PowerFiendUlt") ||
				CheckInventory("PowerKanKan") ||
				CheckInventory("PowerShieldGate")
			)
			{
				return 0;
			}

			if(CheckActorClass(0, "MaximusPrime"))
			{
				if(directMonsterDamage) // Reduce Melee Damage
				{
					fixedDamage = fixedmul(arg1<<16, 0.78);
					arg1 = fixedDamage>>16;
					if(arg1 < 1)
						arg1 = 1;
				}

				// Monster melee passes through shields.
				if(CheckInventory("BasicArmor") > 0 && !directMonsterDamage)
				{
					// [JM] Credit to Lucius for "The Force Engine" code referenced/ported here.
					fixedDamage = arg1 << 16;
					int shields = CheckInventory("BasicArmor") << 16;
					int healthDmg = 0;

					// The amount of shield energy left after taking *half* damage.
					int halfShieldDmg = fixedDamage >> 1;
					shields = max(0, shields - halfShieldDmg);

					if (shields < (50<<16))
					{
						// healthDmg += shieldDmg * (1 - shields/50.0)
						int fracDmgToHealth = ONE_16 - fixeddiv(shields, (50<<16));
						healthDmg += fixedmul(fracDmgToHealth, fixedDamage);
					}

					// Now take the other half away.
					shields = max(0, shields - halfShieldDmg);
					TakeInventory("BasicArmor", 99999);
					GiveInventory("NullArmorHack", shields>>16);

					arg1 = healthDmg>>16;
					ActivatorSound("Max/ShieldDamage", 127);

					FadeRange (0, 255, 0, min(fixedmul(fixedDamage, 0.01), 1.0), 0, 255, 0, 0.0, 0.5);
				}
			}
			else if(CheckActorClass(0, "Kunai"))
			{
				if(CheckInventory("BasicArmor") > 0)
				{
					if(arg1 >= 50)
						ActivatorSound("HitHeavy", 127);
					else if(arg1 >= 25)
						ActivatorSound("HitMedium", 127);
					else
						ActivatorSound("HitLight", 127);

					FadeRange (255, 0, 0, min(fixedmul(arg1<<16, 0.01), 1.0), 255, 0, 0, 0.0, 0.5);

					if(arg1 > CheckInventory("BasicArmor") && !CheckInventory("PowerShieldGateCooldown"))
					{
						arg1 = 0;
						GiveInventory("ShieldGate", 1);
						GiveInventory("ShieldGateCooldown", 1);
						GiveInventory("ShieldBlast", 1);
						TakeInventory("BasicArmor", 9999);
						ActivatorSound("ShieldBlast", 127);
					}
				}
			}
		}
		
		if(GetCVar("sh_healthbars"))
		{
			if (victimIsMonster && (arg1 > 0) && (arg1 < GetActorProperty(0, AProp_Health)))
			{		
				if(!CheckInventory("HasHealthBar") && !CheckFlag(0, "SHADOW") && !CheckFlag(0, "INVISIBLE") && !CheckFlag(0, "STEALTH"))
				{
					GiveInventory("HasHealthBar", 1);
					
					ACS_NamedExecuteWithResult("CREATE_HP_BAR", 0);
				}
			}
		}
	}

	return arg1;
}

script "CREATE_HP_BAR" (void)
{
	if(!GetCVar("sh_healthbars"))
		terminate;
	
	// Don't spawn HP bars for enemies with these renderstyles.
	if(GetActorProperty(0, APROP_RenderStyle) == STYLE_Fuzzy ||
	   GetActorProperty(0, APROP_RenderStyle) == STYLE_OptFuzzy ||
	   GetActorProperty(0, APROP_RenderStyle) == STYLE_Shadow)
		terminate;
		
	int barTID = UniqueTID();
	SpawnForced("HealthBar", GetActorX(0), GetActorY(0), GetActorZ(0)+GetActorProperty(0, AProp_Height), barTID, GetActorAngle(0));
	
	int oldTID = ActivatorTID(); // Get target's TID, memorize it.
	int tgtUTID = UniqueTID();
	Thing_ChangeTID(0, tgtUTID); // Give it our unique ID.
	
	// Set activator to the bar, and set its pointers to the target.
	SetActivator(barTID);
	SetPointer(AAPTR_TARGET, tgtUTID);
	SetPointer(AAPTR_TRACER, tgtUTID);
	
	// Restore target's TID back to normal.
	Thing_ChangeTID(tgtUTID, oldTID);
	
	// Zandronum is brainfuck dead stupid and doesn't sync health to clients, so I have to make this serverside and waste a metric fuckton of bandwidth. Joy.
	ACS_NamedExecuteWithResult("HPBAR_LOGIC", 0);
}

script "HPBAR_LOGIC" (void) // CLIENTSIDE // NOPE, CAN'T DO CLIENTSIDE BECAUSE ZAN CAN'T SYNC HEALTH, GO FIGURE!
{
	int barTID = ActivatorTID();
	SetActivatorToTarget(barTID);
	int maxhealth = GetActorProperty(0, AProp_SpawnHealth) << 16;
	int height = GetActorProperty(0, AProp_Height) + 20.0;
	str enemyClass = GetActorClass(0);
	
	height += GetUserVariable(0, "user_hpbar_offset") << 16;
	
	while(1)
	{
		SetActivatorToTarget(barTID);
		int health = GetActorProperty(0, AProp_Health);
		int zoffset = height;
		int selector = FixedDiv(health << 16, maxhealth / 24) >> 16; // Health bar is divided into 24 segments
		str state = strparam(s:"health", d:selector);
		
		if((GetActorZ(0) + height) > (GetActorCeilingZ(0) - 2.0))
			zoffset -= ((GetActorZ(0) + height) - (GetActorCeilingZ(0) - 2.0));
		
		SetActivator(barTID);
		int didWarp = Warp(AAPTR_TARGET, 0, 0, zoffset, 0, WARPF_NOCHECKPOSITION | WARPF_BOB | WARPF_USEPTR | WARPF_COPYINTERPOLATION, "", true, 0, 0, 0);
		if(health <= 0 || !didWarp)
		{
			Thing_Remove(barTID);
			terminate;
		}
		
		SetActorState(barTID, state, true);
		
		delay(1);
	}
}

#define GAMEEVENT_LEVEL_INIT 16
#define GAMEEVENT_SPAWN_LEVELSPAWNED 1
#define GAMEEVENT_SPAWN_RANDOMSPAWNED 2

script "EVENT_HANDLER" (int type, int arg1, int arg2) EVENT
{
	switch (type)
	{
		case GAMEEVENT_ACTOR_ARMORDAMAGED:
		{
			arg1 = handle_damage_event(type, arg1, arg2);
			SetResultValue(arg1);
			break;
		}
		case GAMEEVENT_ACTOR_DAMAGED:
		{
			bool attackerIsEnemy = false;
			if(SetActivator(0, AAPTR_DAMAGE_SOURCE))
			{
				attackerIsEnemy = (CheckFlag(0, "ISMONSTER") && !CheckFlag(0, "FRIENDLY"));
			}

			SetActivator(0, AAPTR_DAMAGE_TARGET);
			if(CheckFlag(0, "ISMONSTER") && !attackerIsEnemy)
			{
				GiveInventory("DamageTallyHack", arg1);
				delay(1);
				int damage = CheckInventory("DamageTallyHack");
				if(damage > 0)
				{
					PrintDamage(damage);
					TakeInventory("DamageTallyHack", 9999);
				}
			}
			break;
		}
		case GAMEEVENT_ACTOR_SPAWNED:
		{
			bool isMapSpawned = (arg1 == GAMEEVENT_SPAWN_LEVELSPAWNED);
			bool canMultiply = (isMapSpawned && CheckFlag(0, "ISMONSTER"));
			
			if(isMapSpawned)
			{
				// Exchange map-placed chainsaws for random inventory item spawner.
				actor_swap("ChainsawGiver", "RandomInventoryItems", 256);
			}

			if(GetCVar("sh_compat_swaps"))
			{
				switch(GetCVar("sh_compat_mode"))
				{
					case WADCOMPAT_MAYHEM18O:
					{
						actor_swap("Speedorspawner", "NamiDarkImp", 256);
						actor_swap("Masterpainisspawner", "Cybruiser", 256);
						actor_swap("DeadLostSoul", "ESoul", 256);
						break;
					}
					case WADCOMPAT_MAYHEM18P:
					{
						actor_swap("CommanderKeen", "SuicideBomber", 256);
						actor_swap("WolfensteinSS", "MayhemPlasmaMarine", 256);
						actor_swap("BaronSpawner", "MayhemGrell", 256);
						actor_swap("Masterpainisspawner", "MayhemImmolator", 256);
						break;
					}
					case WADCOMPAT_MAYHEM19:
					{
						actor_swap("ShotgunZamble", "Mayhem19ShotgunCultist", 256);
						actor_swap("ChaingunZambles", "Mayhem19EliteCultist", 256);
						actor_swap("WolfensteinSS", "Mayhem19PistolCultist", 256);
						actor_swap("Hardrev", "Mayhem19Vampire", 256);
						actor_swap("Fastdemon", "Mayhem19Skellie", 256);
						actor_swap("JIHADReplacer", "Mayhem19Skellie", 256);
						actor_swap("StealthynessDemon", "Mayhem19ShadowImp", 256);
						actor_swap("Hardsoul", "Mayhem19BallOfLightning", 256);
						actor_swap("Lostpainis", "Mayhem19BallOfLightning", 256);
						actor_swap("FatsoSpawner", "Mayhem19SludgeMonster", 256);
						actor_swap("Speedorspawner", "Mayhem19DeathCube", 256);
						actor_swap("Stalagtite", "Mayhem19Satyr", 256);
						actor_swap("DeadLostSoul", "Mayhem19Bat", 256);
						actor_swap("PainisElementalSpawner", "Mayhem19ArmlessElemental", 256);
						actor_swap("HangTSkull", "Mayhem19Shadowhound", 256);
						actor_swap("HangTLookingUp", "Mayhem19TeslaCoil", 256);
						actor_swap("MeatballSpawner", "Mayhem19CacoSpawner", 256);
						actor_swap("HangBNoBrain", "Mayhem19Mummy", 256);
						actor_swap("Hellpainis", "Mayhem19FlyingBrain", 256);
						actor_swap("HangTNoBrain", "Mayhem19DeepOne", 256);
						actor_swap("BaronSpawner", "AracnorbQueen", 256);
						actor_swap("UnholyBible", "Mayhem19Lich", 256);
						actor_swap("Cyberpainis", "Mayhem19Minotaur", 256);
						actor_swap("Masterpainisspawner", "Mayhem19Spooklord", 256);
						break;
					}
					case WADCOMPAT_STRANGEAEONS:
					{
						actor_swap("AK47", "ChaingunGiver", 256);
						actor_swap("Yithgun", "PlasmaRifleGiver", 256);
						actor_swap("ImpalerXBow", "RailgunGiver", 256);
						actor_swap("Devil", "Imps", 64);
						actor_swap("RapidFireTrooper", "Zamble", 64);
						actor_swap("UndeadHunter", "Shotgunzamble", 64);
						actor_swap("Skeleton", "MeleeRevenant", 64);
						actor_swap("HellWarrior", "BaronSpawner", 64);
						actor_swap("SlimeWorm", "JIHADReplacer", 64);
						break;
					}
				}

			}

			if(canMultiply)
			{
				int multiplier = GetCVar("sh_enemy_mult");
					
				switch(GameSkill())
				{
					case SHSKILL_DEMONIC:
					{
						if(multiplier < 2)
							multiplier = 2;
						break;
					}
					case SHSKILL_OKUPLOK:
					{
						multiplier = 100;
						break;
					}
				}
				
				if(multiplier > 1)
					multiply_actor(clamp(multiplier, 2, 100));
			}

			break;
		}
		case GAMEEVENT_LEVEL_INIT:
		{
			detect_wads();
			break;
		}
	}
}

#define AMMO_CLIP		0
#define AMMO_CLIPBOX	1
#define AMMO_SHELLS		2
#define AMMO_SHELLBOX	3
#define AMMO_ROCKET		4
#define AMMO_ROCKETBOX	5
#define AMMO_CELL		6
#define AMMO_CELLBOX	7

#define DROPTYPE_NONE 0
#define DROPTYPE_HALVED 1
#define DROPTYPE_FULL 2
#define DROPTYPE_RANDOM 3

// Brutal shitfuck hack due to Zandronum not networking the "log" command for some buttfuck reason.
// Use with "NamedSendNetworkString".
script "LOGMESSAGE_HACK" (int msg) CLIENTSIDE
{
	log(s:msg);
}

// Gives ammo to player.
// return value is how much was really given after doubling or accounting for capacity.
function int add_ammo(str ammo_class, int amount, int droptype)
{
	if(amount == 0)
		return 0;

	if((GetCvar("sh_ammo_mult") > 1) || (GameSkill() == SHSKILL_OKUPLOK))
	{
		int multiplier = GetCvar("sh_ammo_mult");
		if((GameSkill() == SHSKILL_OKUPLOK) && (multiplier < 4))
			multiplier = 4;
		
		amount *= multiplier;
	}
	else if((GameSkill() == SHSKILL_VERYEASY) || (GameSkill() == SHSKILL_NIGHTMARE) || GetCvar("sv_doubleammo"))
		amount *= 2;

	switch(droptype)
	{
		case DROPTYPE_HALVED:
		{
			amount /= 2;
			if(amount == 0)
				amount = 1;
			break;
		}
		case DROPTYPE_RANDOM:
		{
			amount = random(amount>>1, amount);
			if(amount == 0)
				amount = 1;
			break;
		}
	}

	if(StrIcmp(ammo_class, "None") != 0 && amount > 0)
	{
		if(CheckInventory(ammo_class) < GetAmmoCapacity(ammo_class))
		{
			// Adjust ammo given to remainder of capacity, if applicable.
			// Doing this so I can pass the real amount gained to the pickup message.
			if((CheckInventory(ammo_class) + amount) > GetAmmoCapacity(ammo_class))
				amount = GetAmmoCapacity(ammo_class) - CheckInventory(ammo_class);

			GiveInventory(ammo_class, amount);
			return amount;
		}
	}

	return 0;
}

script 13236 (int type, int dropped) // "AMMO_PICKUP"
{
	SetResultValue(0); // Starting result should always be 0, only set to 1 on success.
	if(IsNetworkGame() && (ConsolePlayerNumber() != -1)) // Hack to prevent Zandronum from executing this on a client
		terminate;

	str ammo1_class = "None";
	str ammo1_name = "None";
	int ammo1_amount = 0;

	str ammo2_class = "None";
	str ammo2_name = "None";
	int ammo2_amount = 0;

	str pickupsound = "misc/i_pkup";
	str extrasound = "None";
	str textcolor = "\cf";

	int droptype = DROPTYPE_HALVED;

	int fade_rgb[3] = { 255, 192, 0 };

	if(CheckActorClass(0, "MaximusPrime"))
		droptype = DROPTYPE_FULL;

	// Our ammo types. Determined by a numerical index passed to the script.
	switch(type)
	{
		case AMMO_CLIP:
		{
			ammo1_class = "PeastolClip";
			ammo1_amount = 12;

			if(CheckActorClass(0, "MaximusPrime"))
			{
				ammo1_class = "DF_EnergyUnit";
				ammo1_amount = 15;
			}
			else if(CheckActorClass(0, "Gosimer"))
			{
				droptype = DROPTYPE_RANDOM;
			}

			pickupsound = "AMMO/CLIP";
			break;
		}
		case AMMO_CLIPBOX:
		{
			ammo1_class = "MGRounds";
			ammo1_amount = 75;

			if(CheckActorClass(0, "MaximusPrime"))
			{
				ammo1_class = "DF_EnergyUnit";
				ammo1_amount = 45;
			}
			else if(CheckActorClass(0, "Fiend"))
			{
				extrasound = "Jim/taunt10";
			}

			pickupsound = "AMMO/CLIP";
			break;
		}
		case AMMO_SHELLS:
		{
			ammo1_class = "Shellz";
			ammo1_amount = 2;

			if(CheckActorClass(0, "MaximusPrime"))
			{
				ammo1_class = "DF_PowerCell";
				ammo1_amount = 10;
			}
			else
			{
				ammo2_class = "Supershellz";
				ammo2_amount = 2;
			}

			pickupsound = "AMMO/SHEL";
			break;
		}
		case AMMO_SHELLBOX:
		{
			ammo1_class = "Shellz";
			ammo1_amount = 10;

			if(CheckActorClass(0, "MaximusPrime"))
			{
				ammo1_class = "DF_PowerCell";
				ammo1_amount = 30;
			}
			else
			{
				ammo2_class = "Supershellz";
				ammo2_amount = 10;
			}

			pickupsound = "AMMO/SHELBAWX";
			break;
		}
		case AMMO_ROCKET:
		{
			ammo1_class = "Roketammo";
			ammo1_amount = 1;

			if(CheckActorClass(0, "MaximusPrime"))
			{
				ammo1_name = "Mortar Shell";
			}
			else if(CheckActorClass(0, "Gosimer"))
			{
				ammo1_name = "Grenade";
			}

			pickupsound = "AMMO/ROKET";
			break;
		}
		case AMMO_ROCKETBOX:
		{
			ammo1_class = "Roketammo";
			ammo1_amount = 5;

			if(CheckActorClass(0, "MaximusPrime"))
			{
				ammo1_name = "Mortar Shell";
			}
			else if(CheckActorClass(0, "Gosimer"))
			{
				ammo1_name = "Grenade";
			}

			pickupsound = "AMMO/ROKETBAWX";
			break;
		}
		case AMMO_CELL:
		{
			ammo1_class = "Battery";
			ammo1_amount = 40;

			ammo2_class = "RailSLUGS";
			ammo2_amount = 6;

			if(CheckActorClass(0, "Fiend"))
			{
				extrasound = "Jim/taunt6";
			}
			else if(CheckActorClass(0, "MaximusPrime"))
			{
				ammo1_class = "DF_PlasmaCartridge";
				ammo1_amount = 20;

				ammo2_name = "Disruptor Cell";
			}
			else if(CheckActorClass(0, "Kunai"))
			{
				ammo2_name = "7.92x57mm Mauser Round";
			}

			pickupsound = "AMMO/BATTERY";
			break;
		}
		case AMMO_CELLBOX:
		{
			ammo1_class = "Battery";
			ammo1_amount = 100;

			ammo2_class = "BFGCHARGE";
			ammo2_amount = 2;

			// Todo: Lightning Ammo.

			if(CheckActorClass(0, "Fiend"))
			{
				extrasound = "Jim/taunt4";
			}
			else if(CheckActorClass(0, "MaximusPrime"))
			{
				ammo1_class = "DF_Missile";
				ammo1_amount = 5;

				ammo2_class = "DF_PlasmaCartridge";
				ammo2_amount = 60;
			}
			else if(CheckActorClass(0, "Gosimer"))
			{
				ammo2_class = "DevastatorAmmo";
				ammo2_amount = 50;
			}

			pickupsound = "AMMO/BATTERYPAK";
			break;
		}
	}

	if(!dropped)
		droptype = DROPTYPE_NONE;

	ammo1_amount = add_ammo(ammo1_class, ammo1_amount, droptype);
	ammo2_amount = add_ammo(ammo2_class, ammo2_amount, droptype);
	bool success = (ammo1_amount || ammo2_amount);

	if(success)
	{
		// If name isn't overridden, use ammo's tag.
		if(!StrIcmp(ammo1_name, "None"))
			ammo1_name = GetClassTag(ammo1_class);
		if(!StrIcmp(ammo2_name, "None"))
			ammo2_name = GetClassTag(ammo2_class);

		str suffix1 = "";
		str suffix2 = "";

		// Add a plural suffix, if applicable.
		if((ammo1_amount) > 1)
			suffix1 = "s";
		if ((ammo2_amount) > 1)
			suffix2 = "s";

		if(CheckActorClass(0, "MaximusPrime"))
		{
			textcolor = "\ci";
			fade_rgb[0] = 0;
			fade_rgb[1] = 0;
			fade_rgb[2] = 255;
		}

		str msg = StrParam(s:textcolor);
		if(ammo1_amount > 0)
		{
			msg = StrParam(s:msg, d:ammo1_amount, s:" ", s:ammo1_name, s:suffix1);
			if(ammo2_amount > 0)
				msg = StrParam(s:msg, s:" & ");
		}

		if(ammo2_amount > 0)
		{
			msg = StrParam(s:msg, d:ammo2_amount, s:" ", s:ammo2_name, s:suffix2);
		}

		NamedSendNetworkString("LOGMESSAGE_HACK", msg, PlayerNumber());

		//if(ammo1_amount > 0 && ammo2_amount > 0)
			//log(s:textcolor, d:ammo1_amount, s:" ", s:ammo1_name, s:suffix1, s:" & ", d:ammo2_amount, s:" ", s:ammo2_name, s:suffix2);
		//else if(ammo1_amount > 0)
			//log(s:textcolor, d:ammo1_amount, s:" ", s:ammo1_name, s:suffix1);

		PlaySound(0, pickupsound, CHAN_ITEM, 1.0, false);
		if(StrIcmp(extrasound, "None") != 0)
			PlaySound(0, extrasound, CHAN_6, 1.0, false);

		FadeRange (fade_rgb[0], fade_rgb[1], fade_rgb[2], 0.25, fade_rgb[0], fade_rgb[1], fade_rgb[2], 0.0, 0.25);

		SetResultValue(1);
	}
}

// ------------------
// Weapon Pickup Code
// ------------------

#define WEAPON_CHAINSAW		0
#define WEAPON_PISTOL		1
#define WEAPON_SHOTGUN		2
#define WEAPON_SSG			3
#define WEAPON_CHAINGUN		4
#define WEAPON_ROCKET		5
#define WEAPON_PLASMA		6
#define WEAPON_BFG			7
#define WEAPON_RAILGUN		8
#define WEAPON_FLAME		9
#define WEAPON_NUKE			10

// Unfinished...

script 13237 (int type, int dropped) // "WEAPON_PICKUP"
{
	SetResultValue(0); // Starting result should always be 0, only set to 1 on success.
	if(IsNetworkGame() && (ConsolePlayerNumber() != -1)) // Hack to prevent Zandronum from executing this on a client
		terminate;

	str weapon_class = "None";
	str pickupsound = "misc/w_pkup";
	str pickupsound_new = "None";

	str ammo1_class = "None";
	str ammo2_class = "None";

	str ammo1_name = "None";
	str ammo2_name = "None";

	str weapontextcolor = "\cd";
	str ammotextcolor = "\cf";

	int ammo1_amount = 0;
	int ammo2_amount = 0;

	int droptype = DROPTYPE_HALVED;

	int tier = 0;

	int fade_rgb[3] = { 255, 192, 0 };

	if(CheckActorClass(0, "MaximusPrime"))
	{
		pickupsound = "Max/HealthBonus";
		droptype = DROPTYPE_FULL;
	}

	switch(type)
	{
		case WEAPON_CHAINSAW:
			weapon_class = "UAC-Chainsaw";
			if(CheckActorClass(0, "Fiend") || CheckActorClass(0, "Gosimer"))
			{
				pickupsound_new = "weapon/Chainget";
			}
			else if(CheckActorClass(0, "Kunai"))
			{
				weapon_class = "Soulreaper";
				pickupsound_new = "Weapon/SRGET";
			}
			else if(CheckActorClass(0, "MaximusPrime"))
			{
				weapon_class = "Lightsaber";
			}
			break;
		case WEAPON_PISTOL:
			SetResultValue(0);  // Unused, for now.
			terminate;
			break;

		case WEAPON_SHOTGUN:
		{
			weapon_class = "D3Shotgun";
			ammo1_class = "Shellz";
			ammo1_amount = 12;

			if(CheckActorClass(0, "Fiend"))
			{
				pickupsound_new = "weapon/singleget";
			}
			else if(CheckActorClass(0, "Kunai"))
			{
				weapon_class = "HelltechShotgun";
				ammo1_amount = 8;
			}
			else if(CheckActorClass(0, "Gosimer"))
			{
				weapon_class = "CombatShotgun";
				ammo1_amount = 8;
			}
			else if(CheckActorClass(0, "MaximusPrime"))
			{
				if(!dropped)
				{
					weapon_class = "Autogun";
					ammo1_class = "DF_PowerCell";
					ammo1_amount = 30;
				}
				else
				{
					weapon_class = "DFBlaster";
					ammo1_class = "DF_EnergyUnit";
					ammo1_amount = 15;
				}
			}
			break;
		}

		case WEAPON_SSG:
		{
			weapon_class = "SuperShawtgun";
			ammo1_class = "SuperShellz";
			ammo1_amount = 8;

			if(CheckActorClass(0, "Fiend"))
			{
				pickupsound_new = "weapon/Fssgget";
			}
			else if(CheckActorClass(0, "Kunai"))
			{
				pickupsound_new = "weapon/StreetsweeperGet";
				weapon_class = "Streetsweeper";
				ammo1_amount = 20;
			}
			else if(CheckActorClass(0, "Gosimer"))
			{
				pickupsound_new = "Weapon/Protoget";
				weapon_class = "BurstShotgun";
				ammo1_amount = 24;
			}
			else if(CheckActorClass(0, "MaximusPrime"))
			{
				weapon_class = "FusionCutter";
				ammo1_class = "DF_PowerCell";
				ammo1_amount = 50;
			}

			break;
		}

		case WEAPON_CHAINGUN:
		{
			weapon_class = "D3Chaingun";
			ammo1_class = "MGRounds";
			ammo1_amount = 20;

			if(CheckActorClass(0, "Fiend"))
			{
				pickupsound_new = "Weapon/Miniget";
			}
			else if(CheckActorClass(0, "Kunai"))
			{
				pickupsound_new = "Weapon/lmgget";
				weapon_class = "PDW";
				ammo1_amount = 50;
			}
			else if(CheckActorClass(0, "Gosimer"))
			{
				pickupsound_new = "Weapon/Ripperget";
				weapon_class = "HMachinegun";
				ammo1_amount = 50;
			}
			else if(CheckActorClass(0, "MaximusPrime"))
			{
				if(!dropped)
				{
					weapon_class = "DFBlaster";
					ammo1_class = "DF_EnergyUnit";
					ammo1_amount = 15;
				}
				else
				{
					weapon_class = "Autogun";
					ammo1_class = "DF_PowerCell";
					ammo1_amount = 30;
				}
			}

			break;
		}

		case WEAPON_ROCKET:
		{
			weapon_class = "Rawketlawnchair";
			ammo1_class = "RoketAmmo";
			ammo1_amount = 5;

			if(CheckActorClass(0, "Fiend"))
			{
				pickupsound_new = "Weapon/Rocketget";
			}
			else if(CheckActorClass(0, "Kunai"))
			{
				pickupsound_new = "Weapon/Bowget";
				weapon_class = "Cryobow";
				ammo1_amount = 5;
			}
			else if(CheckActorClass(0, "Gosimer"))
			{
				pickupsound_new = "Weapon/Nadeget";
				weapon_class = "BoomToob";
				ammo1_amount = 10;
				ammo1_name = "Grenade";
			}
			else if(CheckActorClass(0, "MaximusPrime"))
			{
				weapon_class = "MortarGun";
				ammo1_amount = 3;
				ammo1_name = "Mortar Shell";
			}
			break;
		}

		case WEAPON_PLASMA:
		{
			weapon_class = "DEPlasmaRifle";
			ammo1_class = "Battery";
			ammo1_amount = 40;

			if(CheckActorClass(0, "Fiend"))
			{
				pickupsound_new = "weapon/Plasmaget";
			}
			else if(CheckActorClass(0, "Kunai"))
			{
				pickupsound_new = "Weapon/ChannlerGet";
				weapon_class = "Channeler";
				ammo1_amount = 40;
			}
			else if(CheckActorClass(0, "Gosimer"))
			{
				pickupsound_new = "Weapon/thunderboltget";
				weapon_class = "Lightning_Rifle";
				ammo1_amount = 40;
			}
			else if(CheckActorClass(0, "MaximusPrime"))
			{
				weapon_class = "ConcRifle";
				ammo1_class = "DF_PowerCell";
				ammo1_amount = 100;
			}
			break;
		}
		
		case WEAPON_RAILGUN:
		{
			weapon_class = "FiendsRailgun";
			ammo1_class = "Railslugs";
			ammo1_amount = 10;

			if(CheckActorClass(0, "Fiend"))
			{
				pickupsound_new = "weapon/RAILGET";
			}
			else if(CheckActorClass(0, "Kunai"))
			{
				weapon_class = "KunaisKar98";
				ammo1_amount = 5;
				ammo1_name = "7.92x57mm Mauser Round";
			}
			else if(CheckActorClass(0, "Gosimer"))
			{
				weapon_class = "Propulsion_Rifle";
			}
			else if(CheckActorClass(0, "MaximusPrime"))
			{
				weapon_class = "DisruptorRifle";
				ammo1_amount = 8;
				ammo1_name = "Disruptor Cell";
			}
			break;
		}

		case WEAPON_BFG:
		{
			weapon_class = "debfg9500";
			ammo1_class = "bfgcharge";
			ammo1_amount = 1;

			if(CheckActorClass(0, "Fiend"))
			{
				pickupsound_new = "weapon/bfgget";
			}
			else if(CheckActorClass(0, "Kunai"))
			{
				pickupsound_new = "Weapon/Vortexget";
				weapon_class = "Vortexgun";
				ammo1_amount = 2;
			}
			else if(CheckActorClass(0, "Gosimer"))
			{
				pickupsound_new = "Weapon/devistatorget";
				weapon_class = "micro_Devistator";
				ammo1_class = "DevastatorAmmo";
				ammo1_amount = 60;
			}
			else if(CheckActorClass(0, "MaximusPrime"))
			{
				weapon_class = "AssaultCannon";
				ammo1_class = "DF_PlasmaCartridge";
				ammo1_amount = 30;
				ammo2_class = "DF_Missile";
				ammo2_amount = 2;
			}
			break;
		}
	}

	if(!dropped)
	{
		droptype = DROPTYPE_NONE;
		// If weapon is set to stay, and weapon already given.
		if(GetCVar("sv_weaponstay") && CheckInventory(weapon_class))
			terminate;
	}

	ammo1_amount = add_ammo(ammo1_class, ammo1_amount, droptype);
	ammo2_amount = add_ammo(ammo2_class, ammo2_amount, droptype);
	bool success = (ammo1_amount || ammo2_amount || !CheckInventory(weapon_class));
	if(success)
	{
		bool isNew = false;
		if(!CheckInventory(weapon_class))
		{
			GiveInventory(weapon_class, 1);
			if(GetUserCVar(PlayerNumber(), "switchonpickup") > 1)
				SetWeapon(weapon_class);

			isNew = true;
		}

		// If name isn't overridden, use ammo's tag.
		if(!StrIcmp(ammo1_name, "None"))
			ammo1_name = GetClassTag(ammo1_class);
		if(!StrIcmp(ammo2_name, "None"))
			ammo2_name = GetClassTag(ammo2_class);

		str suffix1 = "";
		str suffix2 = "";

		// Add a plural suffix, if applicable.
		if((ammo1_amount) > 1)
			suffix1 = "s";
		if ((ammo2_amount) > 1)
			suffix2 = "s";

		if(CheckActorClass(0, "MaximusPrime"))
		{
			ammotextcolor = "\ci";
			fade_rgb[0] = 0;
			fade_rgb[1] = 0;
			fade_rgb[2] = 255;
		}

		str weapon_name = GetClassTag(weapon_class);

		str msg = StrParam(s:weapontextcolor, s:weapon_name);

		if(ammo1_amount > 0 || ammo2_amount > 0)
			msg = StrParam(s:msg, s:ammotextcolor, s:" (+");

		if(ammo1_amount > 0)
		{
			msg = StrParam(s:msg, d:ammo1_amount, s:" ", s:ammo1_name, s:suffix1);
			if(ammo2_amount > 0)
				msg = StrParam(s:msg, s:" & ");
		}

		if(ammo2_amount > 0)
		{
			msg = StrParam(s:msg, d:ammo2_amount, s:" ", s:ammo2_name, s:suffix2);
		}

		if(ammo1_amount || ammo2_amount)
			msg = StrParam(s:msg, s:")");

		NamedSendNetworkString("LOGMESSAGE_HACK", msg, PlayerNumber());

		if(isNew && (StrIcmp(pickupsound_new, "None") != 0))
			PlaySound(0, pickupsound_new, CHAN_ITEM, 1.0, false);
		else
			PlaySound(0, pickupsound, CHAN_ITEM, 1.0, false);

		FadeRange (fade_rgb[0], fade_rgb[1], fade_rgb[2], 0.25, fade_rgb[0], fade_rgb[1], fade_rgb[2], 0.0, 0.25);

		if(!GetCVar("sv_weaponstay") || dropped)
			SetResultValue(1);
	}
}

// --------------------------------

script 13238 (void) // "PICK_UP_SENTRY"
{
	if(IsNetworkGame() && (ConsolePlayerNumber() != -1)) // Hack to prevent Zandronum from executing this on a client
		terminate;

	SetResultValue(0);

	int playerNum = PlayerNumber();
	if(CheckInventory("UsedSentryBox"))
	{
		Print(s:"You are already carrying a sentry!");
		terminate;
	}

	SetActivator(0, AAPTR_TARGET);
	int health = GetActorProperty(0, APROP_Health);
	int owner = GetUserVariable(0, "user_owner");
	SetActivatorToPlayer(playerNum);

	if(owner != playerNum)
	{
		Print(s:"This sentry belongs to ", n:owner+1);
		terminate;
	}

	GiveInventory("SentryHealth", health);
	GiveInventory("UsedSentryBox", 1);

	Print(s:"\ccPicked up sentry with \cd", d:health, s:"\cc health remaining.");

	SetActivator(0, AAPTR_TARGET);
	Thing_Remove(0);
}

script "DROP_SENTRY" (bool used)
{
	if(IsNetworkGame() && (ConsolePlayerNumber() != -1)) // Hack to prevent Zandronum from executing this on a client
		terminate;

	int playerNum = PlayerNumber();
	int health = CheckInventory("SentryHealth");
	int uTID = UniqueTID();

	int distance = 50.0;
	int angle = GetActorAngle(0);
	int x = GetActorX(0) + FixedMul(cos(angle), distance);
	int y = GetActorY(0) + FixedMul(sin(angle), distance);
	int z = GetActorZ(0) + 24.0;

	bool success = Spawn("MiniSentryGun", x, y, z, uTID, angle>>8);
	if(success)
	{
		if(used)
		{
			SetActorProperty(uTID, APROP_Health, health);
			TakeInventory("SentryHealth", health);
		}

		SetUserVariable(uTID, "user_owner", playerNum);
		Thing_SetTranslation(uTID, -1);
		ThrustThing(angle>>8, 2, true, uTID);
	}
	else
	{
		Print(s:"\cgCannot place sentry, something is blocking the way!");
	}

	SetResultValue(success);
}

// --------------------------------
// Clientside Pickup Transformation
// --------------------------------

script "SET_PICKUP_SPRITE" (void) CLIENTSIDE
{
	if(ConsolePlayerNumber() == -1)
		terminate;

	int oldTID = ActivatorTID();
	int newTID = UniqueTID();
	Thing_ChangeTID(0, newTID);

	SetActivatorToPlayer(ConsolePlayerNumber());
	SetActivator(0, AAPTR_PLAYER_GETCAMERA);
	str playerClassName = GetActorClass(0);
	str scaleVar = StrParam(s:"user_scale_", s:playerClassName);

	SetActivator(newTID);
	SetActorState(0, "SetScale", false);

	bool stateSet = false;
	if(CheckFlag(0, "DROPPED"))
	{
		str droppedState = StrParam(s:playerClassName, s:"Dropped");
		stateSet = SetActorState(0, droppedState, false);
	}

	if(!stateSet)
		stateSet = SetActorState(0, playerClassName, false);

	if(!stateSet)
		SetActorState(0, "Base", false);

	// Hack to bypass the fact that Zan can't use A_SetScale from the client side on non-clientsided actors.
	if(GetUserVariable(0, scaleVar) > 0)
	{
		SetActorProperty(0, APROP_ScaleX, GetUserVariable(0, scaleVar)*0.01);
		SetActorProperty(0, APROP_ScaleY, GetUserVariable(0, scaleVar)*0.01);
	}
	else if(GetUserVariable(0, "user_scale_Base") > 0)
	{
		SetActorProperty(0, APROP_ScaleX, GetUserVariable(0, "user_scale_Base")*0.01);
		SetActorProperty(0, APROP_ScaleY, GetUserVariable(0, "user_scale_Base")*0.01);
	}

	Thing_ChangeTID(0, oldTID);
}

// -----------------------------

script "SUPERCHARGE_CHECK" (void)
{
	if(CheckInventory("PowerDoubleFiringSpeed"))
	{
		SetUserVariable(0, "user_supercharge_useammo", (GetUserVariable(0, "user_supercharge_useammo")+1) & 1);
		SetResultValue(GetUserVariable(0, "user_supercharge_useammo"));

		if(GetCVar("sh_debug_weapons"))
			log(s:"DEBUG: user_supercharge_useammo ", d:GetUserVariable(0, "user_supercharge_useammo"));
	}
	else
		SetResultValue(1);
}

script "UNSTICK_PLAYER" (str who)
{
	if(!StrIcmp(who, "all") || !StrIcmp(who, "everyone"))
	{
		for(int p = 0; p < MAX_PLAYERS; p++)
		{
			if(!PlayerInGame(p))
				continue;

			SetActivatorToPlayer(p);

			GiveInventory("TeleportHax", 1);
		}
	}
}
